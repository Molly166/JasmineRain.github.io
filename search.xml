<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Segment tree</title>
      <link href="/JasmineRain.github.io/2025/08/19/Segment-tree/"/>
      <url>/JasmineRain.github.io/2025/08/19/Segment-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><p>线段树是主要用来维护<strong>区间信息</strong>的数据结构<br>线段树可以在O(logN)的时间复杂度内实现单点修改、区间修改、区间查询(区间求和、求区间最大值、求区间最小值)等操作</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>将数组<code>a=&#123;10,11,12,13,14&#125;</code>转化为线段树:设线段树的根节点编号为1，用数组d来保存我们的线段树,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>用来保存线段树上编号为i的节点的值，这里每个节点所维护的值就是这个节点所表示的区间总和。</p><p><img src="/JasmineRain.github.io/./Segment-tree/SegmentTree001.png" alt="线段树的形态"></p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的左儿子节点就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mn>2</mn><mo>∗</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{2*i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的右儿子节点就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">d_{2*i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>.如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示的是区间[s,t](即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">a_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{s+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>+...+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)的话，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的左儿子节点表示的是区间[s,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1696em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8246em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>],<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的右儿子表示的区间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1696em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8246em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>+1到t的闭区间<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>在实现时，我们考虑递归建树。设当前的根节点为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,如果根节点管辖的区间长度已经是1,则可以直接根据<code>a</code>数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。</p><ul><li>c++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 移位运算符的优先级小于加减法，所以加上括号</span></span><br><span class="line">  <span class="comment">// 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围</span></span><br><span class="line">  <span class="built_in">build</span>(s, m, p * <span class="number">2</span>), <span class="built_in">build</span>(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>python</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">s, t, p</span>):</span><br><span class="line">    <span class="comment"># 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">    <span class="keyword">if</span> s == t:</span><br><span class="line">        d[p] = a[s]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    m = s + ((t - s) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 移位运算符的优先级小于加减法，所以加上括号</span></span><br><span class="line">    <span class="comment"># 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围</span></span><br><span class="line">    build(s, m, p * <span class="number">2</span>)</span><br><span class="line">    build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 递归对左右区间建树</span></span><br><span class="line">    d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li>golang</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设数组 a 和线段树数组 d 已经定义</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> d []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(s, t, p <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 对 [s,t] 区间建立线段树，当前根的编号为 p</span></span><br><span class="line">    <span class="keyword">if</span> s == t &#123;</span><br><span class="line">        d[p] = a[s]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m := s + ((t - s) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">    build(s, m, p*<span class="number">2</span>)</span><br><span class="line">    build(m+<span class="number">1</span>, t, p*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    d[p] = d[p*<span class="number">2</span>] + d[p*<span class="number">2</span>+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 示例</span></span><br><span class="line">    a = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 下标从 1 开始</span></span><br><span class="line">    d = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>*<span class="built_in">len</span>(a))</span><br><span class="line">    build(<span class="number">1</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] a; <span class="comment">// 原数组，下标从 1 开始</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] d; <span class="comment">// 线段树数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="comment">// 对 [s,t] 区间建立线段树，当前根的编号为 p</span></span><br><span class="line">        <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">            d[p] = a[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">        build(s, m, p * <span class="number">2</span>);</span><br><span class="line">        build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        d[p] = d[p * <span class="number">2</span>] + d[p * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 下标从 1 开始</span></span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * a.length];</span><br><span class="line">        build(<span class="number">1</span>, a.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != <span class="number">0</span>) System.out.print(val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于线段树的空间:如果采用堆式存储,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>p</mi></mrow><annotation encoding="application/x-tex">2p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal">p</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>的左儿子,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2p+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>的右儿子,若有<code>n</code>个叶子节点,则<code>d</code>数组的范围最大为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">⌉</mo><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{\lceil log_n \rceil +1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">⌉</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>容易知道线段树的深度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil log_n \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⌉</span></span></span></span>的，则在堆式存储情况下叶子节点(包括无用的叶子节点)数量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo fence="true">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">⌉</mo></mrow></msup></mrow><annotation encoding="application/x-tex">2^{\left\lceil\log{n}\right\rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span></span></span></span></span></span></span></span></span></span></span></span>个，又由于其为一棵完全二叉树，则其总节点个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mrow><mo fence="true">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{\left\lceil\log{n}\right\rceil+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1。当然如果你懒得计算的话可以直接把数组长度设为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">4n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span></span></span></span>，因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msup><mn>2</mn><mrow><mrow><mo fence="true">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{2^{\left\lceil\log{n}\right\rceil+1}-1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4157em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0707em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667em;"><span style="top:-2.9667em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5357em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="mspace mtight" style="margin-right:0.2453em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的最大值在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mi>x</mi></msup><mo>+</mo><mn>1</mn><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><msub><mi>N</mi><mo lspace="0em" rspace="0em">+</mo></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=2^{x}+1(x\in N_{+})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>时取到，此时节点数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mrow><mo fence="true">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><msup><mn>2</mn><mrow><mi>x</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>4</mn><mi>n</mi><mo>−</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">2^{\left\lceil\log{n}\right\rceil+1}-1=2^{x+2}-1=4n-5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span></p></blockquote><p>而堆式存储存在无用的叶子节点，可以考虑使用内存池管理线段树节点，每当需要新建节点时从池中获取。自底向上考虑，必有每两个底层节点合并为一个上层节点，因此可以类似哈夫曼树地证明，如果有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个叶子节点，这样的线段树总共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个节点。其空间效率优于堆式存储，并且是可能的最优情况</p><p>这样的线段树可以自底向上维护</p>]]></content>
      
      
      <categories>
          
          <category> DataStruct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> segment tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux common commands</title>
      <link href="/JasmineRain.github.io/2025/08/19/Linux-common-commands/"/>
      <url>/JasmineRain.github.io/2025/08/19/Linux-common-commands/</url>
      
        <content type="html"><![CDATA[<h2 id="文件与目录操作"><a href="#文件与目录操作" class="headerlink" title="文件与目录操作"></a>文件与目录操作</h2><p>ls -lh<br>以人类可读方式显示文件大小</p><p>ls -ltr<br>按时间排序</p><p>cd -<br>返回上一个目录</p><p>tree<br>树型结构显示目录，需要安装</p><p>stat file<br>查看文件详细信息</p><p>basename &#x2F;path&#x2F;file.txt<br>获取文件名</p><p>dirname &#x2F;path&#x2F;file.txt<br>获取文件路径</p><h2 id="文件查看与处理"><a href="#文件查看与处理" class="headerlink" title="文件查看与处理"></a>文件查看与处理</h2><p>cat -n file<br>显示行号</p><p>tac file<br>反向输出文件</p><p>less -N file<br>分页并显示行号</p><p>strings file<br>提取二进制文件中的字符串</p><p>split -l 1000 big.txt part_<br>按行切割文件</p><p>sort file<br>排序</p><p>uniq file<br>去重</p><p>diff file1 file2<br>比较两个文件</p><p>cmp file1 file2<br>比较两个文件是否相同</p><h2 id="权限与用户管理"><a href="#权限与用户管理" class="headerlink" title="权限与用户管理"></a>权限与用户管理</h2><p>chmod 644 file<br>rw-r–r–</p><p>chmod u+x file<br>给用户添加执行权限</p><p>umask<br>查看默认权限掩码</p><p>chgrp group file<br>修改文件所属组</p><p>groups user<br>查看用户所属组</p><p>useradd newuser<br>添加用户</p><p>usermod -aG sudo u<br>将用户加入sudo组</p><p>userdel -r user<br>删除用户及家目录</p><p>groupadd dev<br>新建用户组</p><h2 id="系统信息与硬件"><a href="#系统信息与硬件" class="headerlink" title="系统信息与硬件"></a>系统信息与硬件</h2><p>uname -r<br>查看内核版本</p><p>cat &#x2F;etc&#x2F;os-release<br>系统版本信息</p><p>hostnamectl<br>查看主机信息</p><p>uptime -p<br>只显示运行时长</p><p>lsblk<br>显示磁盘挂载</p><p>blkid<br>查看磁盘 UUID</p><p>mount &#x2F;dev&#x2F;sdb1 &#x2F;mnt<br>挂载磁盘</p><p>umount &#x2F;mnt<br>卸载磁盘</p><p>lscpu<br>CPU 信息</p><p>lsusb<br>USB 设备</p><p>lspci<br>PCI 设备</p><h2 id="进程与任务管理"><a href="#进程与任务管理" class="headerlink" title="进程与任务管理"></a>进程与任务管理</h2><p>ps -ef | grep ssh<br>查找进程</p><p>pgrep -u user<br>查看用户进程 PID</p><p>kill -15 1234<br>优雅终止进程</p><p>kill -9 1234<br>强制终止</p><p>pkill nginx<br>杀死 nginx 进程</p><p>top -u user<br>查看用户进程</p><p>htop<br>更友好的进程监控</p><p>jobs<br>后台任务</p><p>fg %1<br>任务恢复前台</p><p>bg %1<br>后台继续运行</p><h2 id="磁盘与文件系统"><a href="#磁盘与文件系统" class="headerlink" title="磁盘与文件系统"></a>磁盘与文件系统</h2><p>df -Th<br>查看磁盘文件系统类型</p><p>du -sh *<br>查看当前目录下文件大小</p><p>ls -lh &#x2F;var&#x2F;log<br>查看日志大小</p><p>ncdu<br>图形化磁盘分析工具（需安装）</p><p>fsck &#x2F;dev&#x2F;sdb1<br>检查文件系统</p><p>mount -o remount,rw &#x2F;<br>重新挂载为可写</p><h2 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h2><p>tar -cvf a.tar dir&#x2F;<br>打包</p><p>tar -xvf a.tar<br>解包</p><p>tar -czvf a.tar.gz dir<br>打包并压缩</p><p>tar -xzvf a.tar.gz<br>解压缩</p><p>zip -r a.zip dir&#x2F;<br>压缩 zip</p><p>unzip a.zip -d dir&#x2F;<br>解压到目录</p><p>xz -z file<br>压缩为 .xz</p><p>xz -d file.xz<br>解压</p><h2 id="网络与传输"><a href="#网络与传输" class="headerlink" title="网络与传输"></a>网络与传输</h2><p>ping -c 4 baidu.com<br>ping 4 次</p><p>curl -I <a href="http://url/">http://url</a><br>查看响应头</p><p>curl -O <a href="http://url/file">http://url/file</a><br>下载文件</p><p>wget -c <a href="http://url/file">http://url/file</a><br>断点续传下载</p><p>scp file user@ip:&#x2F;dir&#x2F;<br>上传文件</p><p>scp user@ip:&#x2F;dir&#x2F;file .&#x2F;<br>下载文件</p><p>rsync -avz src&#x2F; dest&#x2F;<br>高效同步文件</p><p>ssh user@ip<br>远程登录</p><p>ssh -p 2222 user@ip<br>指定端口</p><h2 id="网络管理与排错"><a href="#网络管理与排错" class="headerlink" title="网络管理与排错"></a>网络管理与排错</h2><p>ifconfig<br>查看网卡信息（旧）</p><p>ip addr show<br>查看网卡信息（推荐）</p><p>ip route<br>查看路由表</p><p>netstat -tulnp<br>查看端口</p><p>ss -lntp<br>新版端口查看</p><p>traceroute baidu.com<br>路由跟踪</p><p>dig baidu.com<br>DNS 解析</p><p>nslookup baidu.com<br>DNS 查询</p><p>telnet ip port<br>测试端口连通性</p><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="Ubuntu-Debian系"><a href="#Ubuntu-Debian系" class="headerlink" title="Ubuntu&#x2F;Debian系"></a>Ubuntu&#x2F;Debian系</h3><p>apt update<br>apt upgrade<br>apt install pkg<br>apt remove pkg<br>dpkg -i file.deb<br>安装本地包</p><h3 id="CentOS-RedHat系"><a href="#CentOS-RedHat系" class="headerlink" title="CentOS&#x2F;RedHat系"></a>CentOS&#x2F;RedHat系</h3><p>yum install pkg<br>yum remove pkg<br>yum update<br>rpm -ivh file.rpm<br>安装本地包</p><h2 id="日志与系统监控"><a href="#日志与系统监控" class="headerlink" title="日志与系统监控"></a>日志与系统监控</h2><p>journalctl -xe<br>查看系统日志</p><p>tail -f &#x2F;var&#x2F;log&#x2F;syslog<br>实时日志</p><p>tail -f &#x2F;var&#x2F;log&#x2F;messages<br>last<br>登录历史</p><p>w<br>登录用户及进程</p><p>uptime<br>系统负载</p><p>vmstat 2<br>每 2 秒显示内存&#x2F;CPU</p><p>iostat -x 1<br>磁盘 IO</p><p>sar -u 1 10<br>CPU 性能监控</p><h2 id="Shell快捷与工具"><a href="#Shell快捷与工具" class="headerlink" title="Shell快捷与工具"></a>Shell快捷与工具</h2><p>!!<br>执行上一条命令</p><p>!ls<br>执行最近的 ls 命令</p><p>history | grep xx<br>搜索历史命令</p><p>alias ll&#x3D;’ls -l’<br>设置别名</p><p>unalias ll<br>删除别名</p><p>echo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">PATH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>查看环境变量</p><p>export VAR&#x3D;123<br>设置环境变量</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to use git</title>
      <link href="/JasmineRain.github.io/2025/08/18/How-to-use-git/"/>
      <url>/JasmineRain.github.io/2025/08/18/How-to-use-git/</url>
      
        <content type="html"><![CDATA[<h2 id="本地开发阶段"><a href="#本地开发阶段" class="headerlink" title="本地开发阶段"></a>本地开发阶段</h2><h3 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h3><ul><li><p>git init<br>初始化本地仓库</p></li><li><p>git clone &lt; repo &gt;<br>克隆远程仓库</p></li><li><p>git remote -v<br>查看远程仓库地址</p></li><li><p>git remote add origin &lt; url &gt;<br>添加远程仓库地址</p></li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li><p>git branch<br>查看分支</p></li><li><p>git branch dev<br>创建分支</p></li><li><p>git checkout dev&#x2F;git switch dev<br>切换分支</p></li><li><p>git checkout -b feature-x<br>新建并切换分支</p></li><li><p>git branch -d branch-name<br>删除本地分支</p></li><li><p>git branch -vv<br>查看本地分支与远程分支的关系</p></li></ul><h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><ul><li><p>git status<br>查看修改状态</p></li><li><p>git diff<br>查看改动内容</p></li><li><p>git add file<br>添加到暂存区</p></li><li><p>git add .<br>添加全部修改</p></li><li><p>git commit -m “feat:xxx”<br>提交代码</p></li><li><p>git commit –amend<br>修改最近一次commit</p></li><li><p>git restore file<br>撤销修改</p></li><li><p>git reset –hard HEAD<br>撤销到最后一次提交</p></li></ul><h2 id="与远程仓库交互"><a href="#与远程仓库交互" class="headerlink" title="与远程仓库交互"></a>与远程仓库交互</h2><h3 id="拉取更新"><a href="#拉取更新" class="headerlink" title="拉取更新"></a>拉取更新</h3><ul><li><p>git fetch<br>获取远程更新但不合并</p></li><li><p>git pull<br>获取远程更新并合并</p></li><li><p>git pull –rebase<br>获取远程更新并rebase</p></li></ul><h3 id="推送代码"><a href="#推送代码" class="headerlink" title="推送代码"></a>推送代码</h3><ul><li><p>git push origin dev<br>推送分支</p></li><li><p>git push -u origin dev<br>第一次推送并建立跟踪关系</p></li><li><p>git push –force<br>强制推送</p></li></ul><h3 id="远程分支管理"><a href="#远程分支管理" class="headerlink" title="远程分支管理"></a>远程分支管理</h3><ul><li><p>git branch -r<br>查看远程分支</p></li><li><p>git push origin –delete branch_name<br>删除远程分支</p></li><li><p>git fetch -p<br>清理本地已删除的远程分支</p></li></ul><h2 id="协作开发"><a href="#协作开发" class="headerlink" title="协作开发"></a>协作开发</h2><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul><li><p>git merge dev<br>合并分支</p></li><li><p>gti merge –no-ff dev<br>保留分支记录</p></li><li><p>git merge –squash dev<br>合并为一个commit</p></li></ul><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>发生冲突时git会标记&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD … &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; … &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>修改后git add file &amp;&amp; gti commit</p><h3 id="变基rebase"><a href="#变基rebase" class="headerlink" title="变基rebase"></a>变基rebase</h3><ul><li><p>git rebase main<br>把当前分支基于main更新</p></li><li><p>git rebase -i HEAD~3<br>交互式rebase(压缩、修改commit)</p></li></ul><h3 id="临时保存"><a href="#临时保存" class="headerlink" title="临时保存"></a>临时保存</h3><ul><li><p>git stash<br>存储未提交的修改</p></li><li><p>git stash pop<br>恢复修改</p></li><li><p>git stash list<br>查看存储列表</p></li></ul><h2 id="提交规范与历史管理"><a href="#提交规范与历史管理" class="headerlink" title="提交规范与历史管理"></a>提交规范与历史管理</h2><h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h3><ul><li><p>git log<br>查看提交日志</p></li><li><p>git log –oneline  –graph<br>简洁图形化日志</p></li><li><p>git blame file<br>查看文件每一行的修改者</p></li></ul><h3 id="撤销-恢复"><a href="#撤销-恢复" class="headerlink" title="撤销&#x2F;恢复"></a>撤销&#x2F;恢复</h3><ul><li><p>git revert commit_id<br>回滚某个提交(生成新提交)</p></li><li><p>git reset –hard commit_id<br>回退到某个提交(破坏性)</p></li><li><p>git checkout commit_id file<br>恢复某个文件到历史版本</p></li></ul><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><ul><li><p>git tag v1.0.0<br>打标签</p></li><li><p>gti push origin v1.0.0<br>推送标签</p></li><li><p>git tag  -d v1.0.0<br>删除本地标签</p></li><li><p>git push origin –delete v1.0.0<br>删除远程标签</p></li></ul><h2 id="团队协作中的高级用法"><a href="#团队协作中的高级用法" class="headerlink" title="团队协作中的高级用法"></a>团队协作中的高级用法</h2><h3 id="代码评审"><a href="#代码评审" class="headerlink" title="代码评审"></a>代码评审</h3><ul><li><p>在 GitHub&#x2F;GitLab 上提交 Pull Request (PR) &#x2F; Merge Request (MR)</p></li><li><p>代码合并前需要 Review</p></li></ul><h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><ul><li><p>git submodule add &lt; repo &gt;<br>引入子模块</p></li><li><p>git submodule update –init –recursive<br>更新子模块</p></li></ul><h3 id="多远程仓库"><a href="#多远程仓库" class="headerlink" title="多远程仓库"></a>多远程仓库</h3><ul><li><p>git remote add upstream &lt; url &gt;<br>添加上游仓库</p></li><li><p>git fetch upstream<br>获取上游更新</p></li><li><p>git rebase upstream&#x2F;main<br>同步上游改动</p></li></ul><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><ul><li><p>pre-commit<br>提交前检查代码格式</p></li><li><p>pre-push<br>推送前运行测试</p></li><li><p>commit-msg<br>检查 commit message 格式</p></li></ul><h2 id="常见场景总结"><a href="#常见场景总结" class="headerlink" title="常见场景总结"></a>常见场景总结</h2><p>拉代码<code>git pull</code><br>开新分支开发<code>git checkout -b feature-xxx</code><br>开发中提交<code>git add . &amp;&amp; git commit -m &quot;feat:xxx&quot;</code><br>推送分支<code>git push origin feature-xxx</code><br>合并代码提交PR&#x2F;MR，由leader审核<br>解决冲突，手动修改后<code>git add &amp;&amp; git commit</code><br>回退代码<code>git revert</code><br>多人协作,每天先<code>git pull --rebase</code>避免冲突</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis&#39;s data type</title>
      <link href="/JasmineRain.github.io/2025/08/18/Redis-s-data-type/"/>
      <url>/JasmineRain.github.io/2025/08/18/Redis-s-data-type/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h2><p>基本的数据存储单元，可以存储字符串、整数或者浮点数<br>string类型是二进制安全的。redis的string可以包含任何数据，比如jpg图片或者序列化的对象<br>string类型是redis最基本的数据类型，string类型的值最大能存储512mb</p><h3 id="string常用命令"><a href="#string常用命令" class="headerlink" title="string常用命令"></a>string常用命令</h3><ul><li>SET key value:设置键的值</li><li>GET key:获取键的值</li><li>INCR key:将键的值加1</li><li>DECR key:将键的值减1</li><li>APPEND key value:将值追加到键的值之后</li></ul><h2 id="哈希hash"><a href="#哈希hash" class="headerlink" title="哈希hash"></a>哈希hash</h2><p>一个键值对集合，可以存储多个字段<br>redis hash是一个键值对集合，类似于一个小型的noSQL数据库<br>redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象<br>每个哈希最多可以存储2^32-1个键值对</p><h3 id="hash常用命令"><a href="#hash常用命令" class="headerlink" title="hash常用命令"></a>hash常用命令</h3><ul><li>HSET key field value:设置哈希表中字段的值</li><li>HGET key field:获取哈希表中字段的值</li><li>HGETALL key:获取哈希表中所有字段和值</li><li>HDEL key field:删除哈希表中的一个或多个字段</li></ul><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><p>一个简单的列表，可以存储一系列的字符串元素<br>redis列表是最简单的字符串列表，按照插入顺序排序<br>列表最多可以存储2^32-1个元素</p><h3 id="list常用命令"><a href="#list常用命令" class="headerlink" title="list常用命令"></a>list常用命令</h3><ul><li>LPUSH key value:将值插入到列表头部</li><li>RPUSH key value:将值插入到列表尾部</li><li>LPOP key:移出并获取列表的第一个元素</li><li>RPOP key:移出并获取列表的最后一个元素</li><li>LRANGE key start stop:获取列表在指定范围(start-stop)内的元素</li></ul><h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>一个无序集合，可以存储不重复的字符串元素<br>redis的set是string类型的无序集合<br>集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)</p><h3 id="set常用命令"><a href="#set常用命令" class="headerlink" title="set常用命令"></a>set常用命令</h3><ul><li>SADD key value:向集合添加一个或多个成员</li><li>SREM key value:移除集合中的一个或多个成员</li><li>SMEMBERS key:返回集合中的所有成员</li><li>SISMEMBER key value:判断是否是集合的成员</li></ul><h2 id="有序集合sorted-set"><a href="#有序集合sorted-set" class="headerlink" title="有序集合sorted set"></a>有序集合sorted set</h2><p>类似于集合，但是每个元素都有一个分数score与之关联<br>redis zset和set一样也是string类型元素的集合，且不允许重复的成员<br>不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序<br>zset的成员是唯一的，但分数却可以重复</p><h3 id="sorted-zset常用命令"><a href="#sorted-zset常用命令" class="headerlink" title="sorted zset常用命令"></a>sorted zset常用命令</h3><ul><li>ZADD key score value:向有序集合添加一个或多个成员，或更新已存在成员的分数</li><li>ZRANGE key start stop [WITHSCORES]:返回指定范围内的成员</li><li>ZREM key value:移除有序集合中的一个或多个成员</li><li>ZSCORE key value:返回有序集合中，成员的分数值</li></ul><h2 id="位图-Bitmaps"><a href="#位图-Bitmaps" class="headerlink" title="位图 Bitmaps"></a>位图 Bitmaps</h2><p>基于字符串类型，可以对每个位进行操作<br>位数组，可以对字符串进行位操作<br>常用于实现布隆过滤器等位操作</p><h2 id="超日志-HyperLogLogs"><a href="#超日志-HyperLogLogs" class="headerlink" title="超日志 HyperLogLogs"></a>超日志 HyperLogLogs</h2><p>用于基数统计，可以估算集合中的唯一元素数量</p><h2 id="地理空间Geospatial"><a href="#地理空间Geospatial" class="headerlink" title="地理空间Geospatial"></a>地理空间Geospatial</h2><p>用于存储地理位置信息<br>支持地理空间索引和半径查询</p><h2 id="发布-订阅Pub-Sub"><a href="#发布-订阅Pub-Sub" class="headerlink" title="发布&#x2F;订阅Pub&#x2F;Sub"></a>发布&#x2F;订阅Pub&#x2F;Sub</h2><p>一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息</p><h2 id="流Streams"><a href="#流Streams" class="headerlink" title="流Streams"></a>流Streams</h2><p>用于消息队列和日志存储，支持消息的持久化和时间排序</p><h2 id="模块Modules"><a href="#模块Modules" class="headerlink" title="模块Modules"></a>模块Modules</h2><p>redis支持动态加载模块，可以拓展redis的功能</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge sort</title>
      <link href="/JasmineRain.github.io/2025/08/18/Merge-sort/"/>
      <url>/JasmineRain.github.io/2025/08/18/Merge-sort/</url>
      
        <content type="html"><![CDATA[<p>归并排序适合处理大规模数据排序，尤其是当需要稳定排序时非常有用</p><h2 id="归并排序原理"><a href="#归并排序原理" class="headerlink" title="归并排序原理"></a>归并排序原理</h2><ol><li>分治Divide，将数组从中间分成两半</li><li>解决conquer，递归地对左右两半分别进行归并排序</li><li>合并combine，将两个已排序的子数组合并成一个有序数组</li></ol><ul><li>时间复杂度：O(n logn)</li><li>空间复杂度：O(n)，需要额外数组用于合并</li><li>稳定排序，相同元素的相对顺序保持不变</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mid := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line">    left := mergeSort(arr[:mid])</span><br><span class="line">    right := mergeSort(arr[mid:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, left[i])</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, right[j])</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, left[i:]...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, right[j:]...)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">    sorted := mergeSort(arr)</span><br><span class="line">    fmt.Println(sorted) <span class="comment">// [1 2 3 4 5 6]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        mergeSortHelper(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSortHelper</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSortHelper(arr, left, mid);</span><br><span class="line">        mergeSortHelper(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) temp[k++] = arr[i++];</span><br><span class="line">            <span class="keyword">else</span> temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; temp.length; p++) arr[left + p] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        mergeSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Merge sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How is data sorting implemented in MySQL?</title>
      <link href="/JasmineRain.github.io/2025/08/18/How-is-data-sorting-implemented-in-MySQL/"/>
      <url>/JasmineRain.github.io/2025/08/18/How-is-data-sorting-implemented-in-MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><p>排序过程中，如果排序字段命中索引，则利用<strong>索引排序</strong><br>反之，使用<strong>文件排序</strong><br>文件排序中，如果数据量少则在内存中排序，具体是使用单路排序或者双路排序<br>如果数据大则利用磁盘文件进行外部排序，一般使用归并排序</p><h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><p>MySQL可以分为索引排序和filesort</p><h3 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h3><p>如果查询中的ORDER BY子句包含的字段已经在索引中，并且索引的排列顺序和ORDER BY子句一致，则可直接利用索引进行排序。这种方式效率高，因为索引有序。</p><h3 id="filesort"><a href="#filesort" class="headerlink" title="filesort"></a>filesort</h3><p>当使用explain分析SQL发现执行计划的extra中包含using filesort的时候，说明它无法应用索引的顺序，而主动排序了。</p><p>如果需要<strong>排序的数据比较少</strong>，则直接在内存中通过<code>sort_buffer</code>就能排了。具体是通过<code>sort_buffer_size</code>参数来控制<code>sort_buffer</code>的大小，如果需要排序的数据量小于<code>sort_buffer</code>则直接在内存中排序，反之需要利用磁盘临时文件排序，性能就比较差了。</p><h4 id="内存排序"><a href="#内存排序" class="headerlink" title="内存排序"></a>内存排序</h4><h5 id="双路排序"><a href="#双路排序" class="headerlink" title="双路排序"></a>双路排序</h5><p>有一个叫<code>max_length_for_sort_data</code>参数，默认是4096字节，如果select列的数据长度超过它，则MySQl采用<strong>row_id排序</strong>，即把row_id(有主键就是主键)+排序字段放置到<code>sort_buffer</code>中排序。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array</title>
      <link href="/JasmineRain.github.io/2025/08/18/Array/"/>
      <url>/JasmineRain.github.io/2025/08/18/Array/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数组是一种<strong>线性数据结构</strong>，用于存储<strong>相同类型的元素</strong>，在内存中是<strong>连续分配</strong>的</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p><strong>固定长度</strong>:声明时需要确定大小(静态数组)，或者动态数组可以扩展长度(for example:Go’s slice,Java’s ArrayList)</p></li><li><p><strong>随机访问</strong>:通过下标在O(1)的时间内访问任意元素</p></li><li><p><strong>连续存储</strong>:方便计算元素的地址，但插入和删除中间元素可能需要移动大量数据</p></li></ol><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定长数组</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">arr[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态数组 slice</span></span><br><span class="line">s:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定长数组</span></span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数组</span></span><br><span class="line"><span class="type">int</span>[] arr2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>按下标访问，注意下标从0开始</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(arr[<span class="number">0</span>])</span><br><span class="line">fmt.Println(s[<span class="built_in">len</span>(s)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.Println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.Println(arr[arr.length-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++&#123;</span><br><span class="line">    fmt.Println(s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> s&#123;</span><br><span class="line">    fmt.Println(i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:arr)&#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>数组固定长度时中间插入&#x2F;删除效率低，需要移动元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">index:=<span class="number">2</span></span><br><span class="line">val:=<span class="number">99</span></span><br><span class="line">s=<span class="built_in">append</span>(s[:index],<span class="built_in">append</span>([]<span class="type">int</span>&#123;val&#125;,s[index:]...)...)</span><br><span class="line">fmt.Println(s)<span class="comment">// [1 2 99 3 4]</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">list.add(<span class="number">2</span>,<span class="number">99</span>);</span><br><span class="line">System.out.Println(list);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStruct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer network</title>
      <link href="/JasmineRain.github.io/2025/08/16/Computer-network/"/>
      <url>/JasmineRain.github.io/2025/08/16/Computer-network/</url>
      
        <content type="html"><![CDATA[<h2 id="basic-network"><a href="#basic-network" class="headerlink" title="basic network"></a>basic network</h2><h3 id="network’s-definition-history-develop"><a href="#network’s-definition-history-develop" class="headerlink" title="network’s definition,history,develop"></a>network’s definition,history,develop</h3><p><strong>computer network</strong>:A collection of autonomous computer systems interconnected in such a way that they can share resources with each other.</p>]]></content>
      
      
      <categories>
          
          <category> Computer network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/JasmineRain.github.io/2025/08/16/Dynamic-Programming/"/>
      <url>/JasmineRain.github.io/2025/08/16/Dynamic-Programming/</url>
      
        <content type="html"><![CDATA[<p>DP is a way that making the question become the more easy little questions to solve.</p><h2 id="basic-dp"><a href="#basic-dp" class="headerlink" title="basic dp"></a>basic dp</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fucking learn damn english</title>
      <link href="/JasmineRain.github.io/2025/08/16/Fucking-learn-damn-english/"/>
      <url>/JasmineRain.github.io/2025/08/16/Fucking-learn-damn-english/</url>
      
        <content type="html"><![CDATA[<p>author<br>accord<br>benefit<br>economic<br>issue<br>impact<br>consumer<br>focus<br>climate<br>concern<br>environment<br>challenge<br>positive<br>process<br>culture<br>community<br>project<br>academic<br>medium<br>design<br>demand<br>mental<br>negative<br>species<br>decade<br>involve<br>remain<br>individual<br>economy<br>expert<br>compare<br>communication<br>account<br>argue<br>access<br>potential<br>claim<br>graduate<br>advantage<br>emotion<br>evidence<br>performance<br>avoid<br>force<br>financial<br>factor<br>disease<br>effective<br>fund<br>cognitive<br>contribute<br>figure<br>protein<br>region<br>attitude<br>management<br>solution<br>fuel<br>insurance<br>behavior<br>credit<br>encourage<br>poverty<br>attract<br>colleague<br>device<br>engage<br>score<br>current<br>professional<br>apply<br>available<br>detail<br>trend</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English Words </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
