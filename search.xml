<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HashMap是如何解决哈希冲突</title>
      <link href="/JasmineRain.github.io/2025/09/15/HashMap%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/"/>
      <url>/JasmineRain.github.io/2025/09/15/HashMap%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>HashMap是一种键值对的存储数据结构，通过哈希函数把key映射到数组下标(bucket),哈希冲突就是不同的key经过哈希函数后得到相同的数组下标，因为数组有限，而key无限，所以冲突是不可避免的</p><h2 id="HashMap常见的解决哈希冲突的方法"><a href="#HashMap常见的解决哈希冲突的方法" class="headerlink" title="HashMap常见的解决哈希冲突的方法"></a>HashMap常见的解决哈希冲突的方法</h2><h3 id="拉链法-Separate-chaining-链地址法"><a href="#拉链法-Separate-chaining-链地址法" class="headerlink" title="拉链法(Separate chaining&#x2F;链地址法)"></a>拉链法(Separate chaining&#x2F;链地址法)</h3><p>每个数组下标不直接存储单个元素，而是存储一个链表或链式结构，当key冲突时，放到这个链表中。</p><p>查找时，根据key的哈希值找到数组的下标，遍历链表，比较key是否相等</p><ul><li><p>优点</p><ul><li>简单易实现</li><li>当冲突少时，效率很高</li></ul></li><li><p>缺点</p><ul><li>链表过长时查找效率下降(后续Java8+用红黑树替换链表提升性能)</li></ul></li></ul><h3 id="地址开放法-Open-Addressing"><a href="#地址开放法-Open-Addressing" class="headerlink" title="地址开放法(Open Addressing)"></a>地址开放法(Open Addressing)</h3><p>所有元素都存储在数组中，没有链表。当冲突发生时，寻找数组中下一个空槽位存放元素。常用探查方式：线性探查(下一个空槽依次查找)、二次探查(查找间隔平方递增，减少群聚现象)、双哈希(用第二个哈希函数计算步长)</p><ul><li><p>优点</p><ul><li>节约内存，不需要链表指针</li></ul></li><li><p>缺点</p><ul><li>数组负载因子过高时，插入&#x2F;查找效率下降</li></ul></li></ul><h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3><p>当哈希冲突严重时，通过扩容数组+重新计算哈希值，把元素分散到更大的数组里，Java中的HashMap在达到负载因子0.75时会自动扩容(容量翻倍),并将链表&#x2F;红黑树元素重新哈希到新数组</p><h2 id="Java中HashMap的冲突处理-核心机制"><a href="#Java中HashMap的冲突处理-核心机制" class="headerlink" title="Java中HashMap的冲突处理(核心机制)"></a>Java中HashMap的冲突处理(核心机制)</h2><h3 id="链表-红黑树"><a href="#链表-红黑树" class="headerlink" title="链表+红黑树"></a>链表+红黑树</h3><ul><li>Java8之前：链表存储冲突元素</li><li>Java8之后：当链表长度&gt;8且数组长度&gt;&#x3D;64-&gt;链表转换成红黑树，查找复杂度O(logn)</li></ul><h3 id="负载因子与扩容"><a href="#负载因子与扩容" class="headerlink" title="负载因子与扩容"></a>负载因子与扩容</h3><ul><li>默认负载因子0.75，超过就扩容并重新分布元素</li></ul><h3 id="哈希函数优化"><a href="#哈希函数优化" class="headerlink" title="哈希函数优化"></a>哈希函数优化</h3><ul><li>HashMap内部对key的hashCode做扰动处理，提高冲突分散性</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优化理论与方法</title>
      <link href="/JasmineRain.github.io/2025/09/12/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
      <url>/JasmineRain.github.io/2025/09/12/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="线性规划与整数规划"><a href="#线性规划与整数规划" class="headerlink" title="线性规划与整数规划"></a>线性规划与整数规划</h2><h3 id="最优化基本要素"><a href="#最优化基本要素" class="headerlink" title="最优化基本要素"></a>最优化基本要素</h3><ol><li>将实际问题抽象地用数学模型来描述</li><li>对数学模型进行必要的简化，并采用适当的最优化方法来求解数学模型</li></ol><p>目标函数、优化变量、约束条件是最优化问题数学模型的三个基本要素</p><h4 id="优化变量"><a href="#优化变量" class="headerlink" title="优化变量"></a>优化变量</h4><p>一个实际的优化方案可以用一组参数来表示。在这些参数中，有些根据要求在优化过程中始终保持不变，这类参数为<strong>常量</strong>。另一些参数的取值则需要在优化过程中调优和优选，一直处于变化的状态，这类变量称为<strong>优化变量</strong>。优化变量必须是独立的参数。</p><h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><h2 id="智能优化方法"><a href="#智能优化方法" class="headerlink" title="智能优化方法"></a>智能优化方法</h2><h2 id="变分法与动态规划"><a href="#变分法与动态规划" class="headerlink" title="变分法与动态规划"></a>变分法与动态规划</h2>]]></content>
      
      
      <categories>
          
          <category> 专业选修课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/JasmineRain.github.io/2025/09/12/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/JasmineRain.github.io/2025/09/12/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h2><ul><li>数据库：有组织地存储数据的集合</li><li>数据库管理系统：用于创建、读取、更新、删除和管理数据库的软件(如MySQL、PostgreSQL、MongoDB、Redis、ClickHouse等)</li><li>两层关系：应用&lt;–&gt;DBMS&lt;–&gt;存储(磁盘&#x2F;SSD、缓存)</li></ul><h2 id="数据库分类与典型场景"><a href="#数据库分类与典型场景" class="headerlink" title="数据库分类与典型场景"></a>数据库分类与典型场景</h2><ul><li>关系型数据库：表、行、列、支持SQL、事务(ACID)。典型：MySQL、PostgreSQL、Oracle。适合OLTP(在线事务处理)</li><li>Key-Value存储:超快速读写，常做缓存&#x2F;会话(Redis、Memcached)</li><li>文档数据库:JSON&#x2F;BSON文档，灵活schema(MongoDB)。适合半结构化数据。</li><li>列式&#x2F;宽式数据库：面向大规模分析、列存储(Cassandra、HBase、ClickHouse)。适合OLAP&#x2F;时序&#x2F;日志分析</li><li>图数据库:关系密集型图查询(Neo4j、JanusGraph)</li><li>时序数据库:时间序列优化(InfluxDB、Prometheus TSDB)</li><li>搜索引擎:全文搜索与倒排索引(Elasticsearch、Solr)</li></ul><h2 id="核心概念与内部机制"><a href="#核心概念与内部机制" class="headerlink" title="核心概念与内部机制"></a>核心概念与内部机制</h2><ul><li>Schema&#x2F;Table&#x2F;Row&#x2F;Column&#x2F;Index&#x2F;View</li><li>主键PK&#x2F;外键FK&#x2F;唯一约束</li><li>事务(Transaction):原子性、一致性、隔离性、持久性——ACID</li><li>WAL(Write-Ahead Log):用于持久化与恢复</li><li>MVCC(多版本并发控制):实现高并发读(Postgres、InnoDB)</li><li>查询优化器&#x2F;施行计划(EXPLAIN):负责选择索引、join顺序、算子等</li><li>Buffer Pool&#x2F;Page Cache:内存缓存命中率影响性能</li></ul><h2 id="事务隔离级别与并发现象"><a href="#事务隔离级别与并发现象" class="headerlink" title="事务隔离级别与并发现象"></a>事务隔离级别与并发现象</h2><ul><li>隔离级别(按强到弱):<code>SERIALIZABLE</code>-&gt;<code>REPEATABLE READ</code>-&gt;<code>READ COMMITTED</code>-&gt;<code>READ UNCOMMITTED</code></li><li>并发异常:Dirty Read(脏读)、Non-repeatable Read(不可重读)-&gt;Phantom(幻读)</li><li>实务：多数OLTP用<code>READ COMMITTED</code>或<code>REPEATABLE READ</code>(MySQL默认是<code>REPEATABLE READ</code>),需要严格一致性时用<code>SERIALIZABLE</code>(代价高)</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>类型：B-tree&#x2F;Hash&#x2F;Bitmap&#x2F;Inverted(全文)</p></li><li><p>选用要点:</p><ul><li>高选择性字段适合索引(能过滤大量行)</li><li>复合索引遵循最左前缀原则</li><li>覆盖索引(Index Only Scan)可以避免回表</li><li>索引会增加写入开销和占用磁盘空间</li></ul></li><li><p>常见命令</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_email <span class="keyword">ON</span> users(email);</span><br><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span><span class="string">&#x27;a@b.com&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h2><ul><li>范式化(1NF,2NF,3NF)：减少冗余、保证一致化，适用于事务系统</li><li>反范化&#x2F;物化视图&#x2F;预聚合：用于性能优化，适合读多写少或分析场景(如电商报表)</li><li>数据仓库建模：星型&#x2F;雪花模型(OLAP)</li></ul><h2 id="分区、分片与扩展策略"><a href="#分区、分片与扩展策略" class="headerlink" title="分区、分片与扩展策略"></a>分区、分片与扩展策略</h2><ul><li>垂直扩展：更强的单机(CPU&#x2F;内存&#x2F;SSD)</li><li>水平扩展：分片(sharding)&#x2F;分区，数据按键范围或哈希分布到多节点</li><li>分区(partition)：单库内按范围&#x2F;列表&#x2F;哈希分区，方便管理与查询优化</li><li>分片要谨慎：选择shard key(会影响热点与重分片成本)</li></ul><h2 id="复制与高可用"><a href="#复制与高可用" class="headerlink" title="复制与高可用"></a>复制与高可用</h2><ul><li>模式:主从(主写从读)、主主(双主)、基于一致性协议(Raft&#x2F;Paxos)</li><li>同步复制(强一致性) vs 异步复制(提升可用&#x2F;性能但有副本延迟)</li><li>常见功能：自动故障切换(failover)、复制延迟监控</li></ul><h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><ul><li>备份类型：逻辑备份(SQL dump)与物理备份&#x2F;快照(更快，可恢复到某一时点)</li><li>WAL+PITR(Point-in-time recovery)：可恢复到某个时间点</li><li>常见策略：定期全备+增量备份+异地存储+定期恢复演练</li></ul><h2 id="安全与权限"><a href="#安全与权限" class="headerlink" title="安全与权限"></a>安全与权限</h2><ul><li>最小权限原则(Role&#x2F;Grant)</li><li>加密：传输层TLS、静态数据加密(at-rest)</li><li>审计日志、敏感数据脱敏&#x2F;掩码、合规(GDPR&#x2F;HIPAA)考虑</li></ul><h2 id="监控指标与排查方向"><a href="#监控指标与排查方向" class="headerlink" title="监控指标与排查方向"></a>监控指标与排查方向</h2><ul><li>基础指标：QPS、响应时间(p95&#x2F;p99)、慢查询数、连续数、CPU、IOPS、磁盘使用、内存使用、缓存命中率、锁等待、复制延迟</li><li>工具：Prometheus+Grafana、各DB自带统计(pg_stat_statements、MySQL Performance Schema)</li></ul><h2 id="常见数据库与推荐场景"><a href="#常见数据库与推荐场景" class="headerlink" title="常见数据库与推荐场景"></a>常见数据库与推荐场景</h2><ul><li>MySQL&#x2F;PostgreSQL：通用OLTP；Postgres强SQL标准、扩展性好；MySQL社区与生态广</li><li>Redis：会话、缓存、队列(轻量)、限流</li><li>MongoDB：文档存储，schema灵活</li><li>Cassandra&#x2F;Scylla：写密集型、线性扩展，最终一致性</li><li>ClickHouse&#x2F;DWH:实时分析、列存储，超快聚合</li><li>Elasticsearch：全文检索与分析</li></ul><h2 id="实战常用SQL示例"><a href="#实战常用SQL示例" class="headerlink" title="实战常用SQL示例"></a>实战常用SQL示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--链表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> users(</span><br><span class="line">    id SERTAL <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email TEXT <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">--事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span>balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span>balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看执行计划(Postgres)</span></span><br><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span><span class="string">&#x27;a@b.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>NoSQL示例(MongoDB)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">users</span>.<span class="title function_">insertOne</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;Alice&quot;</span>,<span class="attr">email</span>:<span class="string">&quot;a@b.com&quot;</span>&#125;);</span><br><span class="line">db.<span class="property">users</span>.<span class="title function_">createIndex</span>(&#123;<span class="attr">email</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">unique</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">db.<span class="property">users</span>.<span class="title function_">find</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;Alice&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>Redis示例</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">session</span>:<span class="number">123</span> <span class="keyword">user</span>:<span class="number">1</span> EX <span class="number">3600</span></span><br><span class="line">HSET <span class="keyword">user</span>:<span class="number">1</span> <span class="type">name</span> &quot;Alice&quot; age &quot;30&quot;</span><br><span class="line"><span class="keyword">GET</span> <span class="keyword">session</span>:<span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="性能调优清单-Checklist"><a href="#性能调优清单-Checklist" class="headerlink" title="性能调优清单(Checklist)"></a>性能调优清单(Checklist)</h2><ul><li>检查慢查询并优化SQL&#x2F;加索引</li><li>合理设计索引，避免过多无用索引</li><li>设计连接池、Prepared Statements、批量写入</li><li>利用缓存(Redis)和读写分离</li><li>避免N+1查询、过度JOIN</li><li>对分析场景使用列式存储&#x2F;ETL到数据仓库</li><li>定期重建碎片化索引&#x2F;VACUUM(Postgres)</li></ul><h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><ul><li>加索引并不都是好事，会增加开销与空间成本</li><li>分片不能无限扩容，分片设计复杂、跨分片join&#x2F;事务很难</li><li>主从复制也是有成本的，存在复制延迟、一致性问题</li></ul><h2 id="选型建议-简单决策树"><a href="#选型建议-简单决策树" class="headerlink" title="选型建议(简单决策树)"></a>选型建议(简单决策树)</h2><ul><li>需要强事务&amp;复杂查询-&gt;PostgreSQL&#x2F;MySQL</li><li>需要极低延迟缓存-&gt;Redis</li><li>文档型灵活schema-&gt;MongoDB</li><li>高并发写入、线性拓展-&gt;Cassandra&#x2F;Scylla</li><li>大数据分析&#x2F;实时OLAP-&gt;ClickHouse&#x2F;BigQuery&#x2F;Snowflake</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础</title>
      <link href="/JasmineRain.github.io/2025/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/JasmineRain.github.io/2025/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="概念与分层模型"><a href="#概念与分层模型" class="headerlink" title="概念与分层模型"></a>概念与分层模型</h2><h3 id="网络的概念"><a href="#网络的概念" class="headerlink" title="网络的概念"></a>网络的概念</h3><p>网络是现代软件系统的基础(分布式系统、微服务系统、云、流媒体、物联网都离不开它)</p><h3 id="两个常见的模型"><a href="#两个常见的模型" class="headerlink" title="两个常见的模型"></a>两个常见的模型</h3><ol><li><p><strong>OSI七层模型</strong>：(物理、数据链路、网络、传输、会话、表示、应用)，便于概念教学所以使用该分层</p></li><li><p><strong>TCP&#x2F;IP(四&#x2F;五层)模型</strong>：(链路&#x2F;网络接口、网络&#x2F;Internet、传输&#x2F;Host-to-Host、应用)，更贴近实际协议栈，(IP&#x2F;TCP&#x2F;UDP&#x2F;HTTP)</p></li></ol><blockquote><p>对照表：<br>1.物理层-&gt;网线&#x2F;光纤&#x2F;无线<br>2.数据链路层-&gt;Ethernet、MAC、ARP、交换机<br>3.网络层-&gt;IP(IPv4&#x2F;IPv6)、路由、ICMP<br>4.传输层-&gt;TCP&#x2F;UDP、端口、流控、拥塞控制<br>5.应用层-&gt;DNS、HTTP、TLS、SMTP、FTP、SSH</p></blockquote><h2 id="物理层与链路层-从线缆到帧"><a href="#物理层与链路层-从线缆到帧" class="headerlink" title="物理层与链路层(从线缆到帧)"></a>物理层与链路层(从线缆到帧)</h2><ul><li><p>物理层：介质(双绞线、光纤、同轴)、信号编码、带宽、噪声、衰减、抖动(jitter)</p></li><li><p>链路层(数据帧):</p><ul><li>MAC地址(48bit,厂商前缀+唯一接口ID)；交换机根据MAC转发</li><li>Ethernet帧结构：目的MAC、源MAC、类型&#x2F;长度、Payload、FCS(CRS)</li><li>ARP(地址解析协议)：把IPv4地址映射到MAC(ARP请求&#x2F;应答)；存在ARP欺骗风险</li><li>交换机vs集线器：集线器广播，交换机基于CAM表转发；交换机隔离碰撞域</li><li>VLAN(虚拟局域网):802.1Q标记帧，使同一物理交换机上存在多个逻辑网络</li><li>生成树协议(STP):防止交换网络环境</li></ul></li></ul><h2 id="网络层：IP、路由、子网"><a href="#网络层：IP、路由、子网" class="headerlink" title="网络层：IP、路由、子网"></a>网络层：IP、路由、子网</h2><ul><li><p>IP地址：</p><ul><li>IPv4(32位)，IPv6(64位)——IPv6没有广播，用邻居发现替代ARP</li><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理</title>
      <link href="/JasmineRain.github.io/2025/09/11/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/JasmineRain.github.io/2025/09/11/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1图像及其分类"><a href="#1-1图像及其分类" class="headerlink" title="1.1图像及其分类"></a>1.1图像及其分类</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>图：是物体反射或投射<strong>电磁波</strong>的分布</p></li><li><p>像：是人的视觉系统对接受的图信息在大脑中形成的印象</p></li><li><p>图像:是图和像的结合。具体来说，就是用<strong>各种观测系统</strong>以不同形式和手段观测客观世界而获得的、可以直接或间接作用于人的视觉系统而产生的视知觉实体</p></li><li><p>图像处理：是对图形信息进行加工以满足人的视觉或应用需求的行为。处理的方法通常有：模拟图像处理、数字图像处理、光电结合处理。</p><ul><li>模拟图像处理：也称光学图像处理，它是利用光学透镜或光学照相(例如：胶片照相机)方法对模拟图像进行的处理，其实时性强、速度快、处理信息量大、分辨率高，但是处理精度差，难有判断功能</li><li>数字图像处理：利用计算机技术或其他数字技术，对图像信息进行某些数字运算和各种加工处理，以改善图像的视觉效果和提高图像实用性的技术</li><li>光电结合处理：用光学方法完成运算量巨大的处理(如频谱变换等)，再用计算机对光学处理结果(如频谱)进行分析判读等处理。该方法是前两种的有机结合，它集结了两者的优点</li></ul></li><li><p>图像处理的基本特征：系统的输入和输出都是图像。核心是<strong>在不改变图像核心内容结构</strong>的前提下，改善图像质量或提取基础特征</p></li><li><p>计算机中图像的表示：定义为二维函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>,其中x，y是空间坐标，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>是点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的幅值；灰度图像是一个二维灰度(或亮度)函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>;彩色图像由三个(如RGB，HSV)二维灰度(或亮度)函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>组成</p></li></ul><p>数字图像由二维的元素组成，每一个元素具有一个特定的位置(x,y)和幅值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，这些元素称为像素</p><ul><li>计算机中的图像的构成：像素组成的二维排列，可以用矩阵表示；对于单色(灰度)图像而言，每个像素的亮度用一个数值来表示，通常数值范围在0到255之间，0表示黑、255表示白，其他值表示处于黑白之间的灰度；彩色图像可以用红、蓝、绿三元组矩阵来表示，通常，三元组的每一个数值也是在0到255之间，0表示相应的基色在该像素中没有，而255则代表相应的基色在该像素中取得最大值</li></ul><h3 id="图像的特点"><a href="#图像的特点" class="headerlink" title="图像的特点"></a>图像的特点</h3><p>直观形象、易懂、信息量大</p><h3 id="图像的分类"><a href="#图像的分类" class="headerlink" title="图像的分类"></a>图像的分类</h3><p>按灰度分类：二值、多灰度<br>按色彩分类：单色、彩色<br>按运动分类：静态、动态<br>按时空分布分类：二维、三维</p><h2 id="1-2-数字图像处理奇数与应用"><a href="#1-2-数字图像处理奇数与应用" class="headerlink" title="1.2 数字图像处理奇数与应用"></a>1.2 数字图像处理奇数与应用</h2><h3 id="数字图像处理的主要内容"><a href="#数字图像处理的主要内容" class="headerlink" title="数字图像处理的主要内容"></a>数字图像处理的主要内容</h3><ul><li>图像获取：把一幅模拟图像转换成适合计算机或数字设备处理的数字信号。包括：摄取图像、光电转换、数字化。</li><li>图像变换：对原始图像进行某种<strong>正交变换</strong>，将图像的特征在变换域中表现出来，一边对图像进行各种相关处理。</li><li>图像增强：突出图像中感兴趣的信息，衰减或去除不需要的信息，以使图像更清晰地被显示后更适合于人或机器的处理与分析</li><li>图像复原：去除噪声干扰和消除模糊，尽可能恢复图像的本来面目。</li><li>图像编码：利用信息论的思想对图像信号进行高效压缩，从而减少数据存储量，降低数据率以减少传输带宽。</li><li>图像分析：对图像中感兴趣的目标进行检测和测量，以获得所需的客观信息。</li><li>图像识别：对图像加以处理和识别，以解决计算机与外部环境直接通信的问题。</li><li>图像理解：研究图像中各种目标的性子以及相互之间的联系，并得以对图像内容含义的理解以及对原来客观场景的解释，从而知道规划行为。</li></ul><h3 id="数字图像处理的方法"><a href="#数字图像处理的方法" class="headerlink" title="数字图像处理的方法"></a>数字图像处理的方法</h3><ul><li>空域法：把图像看作平面中各个像素组成的集合，直接对图像的像素进行处理；（又分为领域处理的方法、点处理的方法）</li><li>变换域法：将图像进行变换后，在变换域内对图像的变换系数进行处理，处理完毕再进行逆变换，获得处理后的图像</li></ul><h3 id="数字图像处理技术的应用"><a href="#数字图像处理技术的应用" class="headerlink" title="数字图像处理技术的应用"></a>数字图像处理技术的应用</h3><ul><li>计算机图像生成：核心是<strong>从无到有</strong>或<strong>基于需求创造图像</strong></li><li>图像传输与图像通信，数字电视</li><li>机器人视觉及图像测量</li><li>办公自动化</li><li>图像跟踪及光学制导</li><li>医学图像处理与材料分析中的图像分析系统</li><li>遥感图像处理和空间探测</li><li>图像变形技术</li></ul><h2 id="1-3-数字图像处理系统"><a href="#1-3-数字图像处理系统" class="headerlink" title="1.3 数字图像处理系统"></a>1.3 数字图像处理系统</h2><h3 id="图像采集系统"><a href="#图像采集系统" class="headerlink" title="图像采集系统"></a>图像采集系统</h3><p>模拟图像-&gt;图像采集系统-&gt;计算机-&gt;图像输出设备</p><h3 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h3><h3 id="图像输出设备"><a href="#图像输出设备" class="headerlink" title="图像输出设备"></a>图像输出设备</h3><h2 id="1-4-MATLAB图像处理工具箱"><a href="#1-4-MATLAB图像处理工具箱" class="headerlink" title="1.4 MATLAB图像处理工具箱"></a>1.4 MATLAB图像处理工具箱</h2><p>MATLAB是一种基于向量的高级程序语言，将计算、可视化与程序设计集成在一个易用的环境中</p><p>。。。。。&#x2F;&#x2F;教授使用过程略</p><h2 id="图像获取"><a href="#图像获取" class="headerlink" title="图像获取"></a>图像获取</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>图像获取是数字图像处理的第一步，它将模拟图像转换成适合数字计算机处理的数字图像</p><p>图像采样：空间坐标位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的离散化(数字化)</p><p>图像量化：图像像素值f的离散化(数字化)</p><h3 id="2-2-连续图像模型"><a href="#2-2-连续图像模型" class="headerlink" title="2.2 连续图像模型"></a>2.2 连续图像模型</h3><p>用<strong>数学方法</strong>表示图像的特征是设计和分析图像处理系统的必要手段；图像特征的数学表示方法：确定性和统计性</p><p>确定性：图像函数是确定的，可用来分析图像的点性质<br>统计的图像表示方法：用统计的平均参数说明图像特征</p>]]></content>
      
      
      <categories>
          
          <category> 专业选修课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些关于Redis</title>
      <link href="/JasmineRain.github.io/2025/09/10/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8ERedis/"/>
      <url>/JasmineRain.github.io/2025/09/10/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8ERedis/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis简单介绍"><a href="#Redis简单介绍" class="headerlink" title="Redis简单介绍"></a>Redis简单介绍</h2><p>Redis是基于内存的高性能key-value存储(支持多种数据结构:string、Hash、List、Set、Sorted Set、Bitmap、HyperLogLog、Stream等)</p><p>内存读写极快，支持持久化(RDB&#x2F;AOF)、单线程处理命令(命令执行是原子性的)、支持复制、哨兵高可用和Cluster分片</p><p>常用场景:缓存、会话、限流、计数器、排行榜、消息队列、分布式锁等</p><p>持久化：RDB(快照):低开销，可能丢数据点(适合备份);AOF(命令追加):更耐久但文件更大、更慢些(可配置fsync策略)</p><p>内存管理&#x2F;驱逐策略：</p><ul><li><code>maxmemory</code>用来限制内存；当满时按<code>maxmemory-policy</code>决定如何驱逐:<code>noeviction</code>、<code>allkeys-lru</code>、<code>volatile-lru</code>、<code>volatile-ttl</code>、<code>allkeys-random</code>等，选<code>allkeys-lru</code>常用于缓存场景</li></ul><p>原子性&#x2F;事务&#x2F;脚本:单命令原子:<code>MULTI/EXEC</code>是事务队列(不保证隔离);Lua脚本在Redis内部执行，整体原子且性能好(常用于实现安全释放锁等)</p><p>集群:RedisCluster按16384个hash slots分片，跨分片的多键操作有限制(需要在同一slot才能多键操作)</p><p>监控与调优:关注<code>INFO</code>、<code>slowlog</code>、内存使用、evictions、命中率(hit ratio)、客户端阻塞等</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h3><p>当多个进程&#x2F;机器并发的访问同一共享资源时，需要分布式锁保证互斥</p><h3 id="分布式锁的必要属性"><a href="#分布式锁的必要属性" class="headerlink" title="分布式锁的必要属性"></a>分布式锁的必要属性</h3><ul><li>互斥性：同一时刻只有一个持有者</li><li>安全释放：只有锁的持有者能释放该锁</li><li>可用性&#x2F;死锁防止：如果持有者崩溃，锁应当在TTL后自动释放，或可被续租</li><li>性能：加&#x2F;释放开销要小</li></ul><h3 id="用Redis实现分布式锁"><a href="#用Redis实现分布式锁" class="headerlink" title="用Redis实现分布式锁"></a>用Redis实现分布式锁</h3><h4 id="获取锁-核心命令"><a href="#获取锁-核心命令" class="headerlink" title="获取锁(核心命令)"></a>获取锁(核心命令)</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value NX PX &lt;ttl&gt;</span><br></pre></td></tr></table></figure><ul><li><code>NX</code>：只在key不存在时设置，相当于SETNX</li><li><code>PX &lt;ttl&gt;</code>:设置过期时间，毫秒</li><li><code>value</code>:必须是唯一标识，例如UUID，用来标记谁是锁的拥有者</li></ul><p>伪代码示例:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clientId=UUID()</span><br><span class="line">ok==redis.set(&quot;lock:order:123&quot;,clientId,NX,PX,10000)</span><br><span class="line">if ok == &quot;OK&quot;:</span><br><span class="line">    //获取资源</span><br><span class="line">else:</span><br><span class="line">    //失败，稍后重试或返回错误</span><br></pre></td></tr></table></figure><h4 id="安全释放-绝对不要用DEL-key直接释放"><a href="#安全释放-绝对不要用DEL-key直接释放" class="headerlink" title="安全释放(绝对不要用DEL key直接释放)"></a>安全释放(绝对不要用<code>DEL key</code>直接释放)</h4><p>必须先检查自己是持有者(vlaue匹配)再删除，最安全的方法用Lua脚本在Redis端原子执行:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- release.lua</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>,KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在客户端：<code>EVAL</code>或<code>EVALSHA</code>执行上述脚本，传参<code>KEYS[1]=lock_key</code>,<code>ARGV[1]=clientId</code></p><h4 id="重试与超时策略-获取锁"><a href="#重试与超时策略-获取锁" class="headerlink" title="重试与超时策略(获取锁)"></a>重试与超时策略(获取锁)</h4><ul><li>避免忙等(spin)；使用指数退避(exponential backoff)或固定短间隔重试直到总超时时间耗尽</li><li>设计合理的lock TTL:<code>ttl=expected_work_time+safety_margin</code>不要设得太短(可能任务还没做完锁就过期)，也不要太长(若持有者挂了，会长时间阻塞别人)</li></ul><h4 id="端续租-续期"><a href="#端续租-续期" class="headerlink" title="端续租(续期)"></a>端续租(续期)</h4><p>如果任务可能比最初预计长，需要一个续租&#x2F;自动刷新机制：</p><ul><li>客户端在锁到期前周期性延长TTL(但要确保只有持有者能延长，检查value)</li><li>风险：客户端暂停&#x2F;GC导致错续，需谨慎；续期一定要有失败回退逻辑</li></ul><p>示例伪代码，获取+释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function tryLock(key,clientId,ttl,waitTimeout):</span><br><span class="line">    endTime=now()+waitTimeout</span><br><span class="line">    while now()&lt;endTime:</span><br><span class="line">        if redis.SET(key,clientId,NX,PX,ttl)==OK:</span><br><span class="line">            return true</span><br><span class="line">        sleep(small_backoff)</span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">function releaseLock(key,clientId):</span><br><span class="line">    -- call Lua script shown above</span><br></pre></td></tr></table></figure><h3 id="Redlock-多节点Redis-和争议"><a href="#Redlock-多节点Redis-和争议" class="headerlink" title="Redlock(多节点Redis)和争议"></a>Redlock(多节点Redis)和争议</h3><ul><li><p>Redlock是Antirez(Redis作者)提出的一个算法：在多个独立Redis节点上尝试拿锁，超过半数即认为获得锁，解锁从所有节点删除。目的是提高可用性&#x2F;容错</p></li><li><p>争议：一些研究&#x2F;文章认为Redlock在网络分区下并不能完全实现强一致性(特别是时钟漂移、网络延迟等)。因此在强一致性要求极高的场景，推荐使用基于<strong>一致性算法</strong>(Paxos&#x2F;Raft)的系统(etcd、Zookeeper、Consul)来做分布式锁</p></li><li><p>工程实践：若场景读写频繁且对性能要求极高，Redis-based lock(单实例或哨兵保证高可用)足够；若需要严格一致性，优先选择etcd&#x2F;sookeeper</p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>不要把锁用于长时间操作，锁持有时间应短</li><li>锁的TTL要比操作预期时间长，但不能过长：若短可能导致自动释放后另一个客户端获得锁并同时有前一个客户端继续执行(重复执行问题)</li><li>释放锁时必须检查owner(Lua)</li><li>不要在锁中做大量I&#x2F;O或阻塞操作(会增加失败概率)</li><li>考虑时钟与网络延迟：不要假设绝对精确的时钟或零延迟</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="常见缓存模式"><a href="#常见缓存模式" class="headerlink" title="常见缓存模式"></a>常见缓存模式</h3><ul><li><p>Cache-Aside(旁路缓存&#x2F;应用控制缓存)：流程：应用先查缓存-&gt;缓存未命中则查数据库-&gt;将结果写入缓存-&gt;返回.写操作：先写DB-&gt;删除&#x2F;更新缓存(或同时更新)。优点：灵活，常用。缺点：需要处理并发写入&#x2F;缓存失效引发的不一致</p></li><li><p>Read-Through&#x2F;Write-Through&#x2F;Write-Behind:</p><ul><li>Read-Through:缓存自己去加载DB(缓存库&#x2F;中间件实现)</li><li>Write-through:写缓存同时写DB(同步)</li><li>Write-behind:写缓存先返回，由后台把缓存写入DB(异步)。这些模式适合不同一致性&#x2F;性能权衡。</li></ul></li><li><p>Stale-While-Revalidate(容忍旧数据，后台刷新)，缓存过期时仍返回旧值给用户，同时后台刷新缓存(减少击穿)</p></li></ul><h3 id="缓存失效问题"><a href="#缓存失效问题" class="headerlink" title="缓存失效问题"></a>缓存失效问题</h3><ul><li><p>缓存穿透:请求大量不存在的数据(或恶意请求)，每次都会落到DB，绕过缓存，造成DB压力</p></li><li><p>缓存击穿&#x2F;缓存穿透(有些文献称”击穿”为热点key失效导致的高并发打到DB)，指某个(热点)key在某一瞬间过期，大量并发请求同时去DB重建缓存，DB瞬时被打垮</p></li><li><p>缓存雪崩(cache avalanche)<br>多个key在同一时间过期&#x2F;缓存服务宕机&#x2F;网络波动导致大面积缓存失效，从而大量请求直接打DB，引发连锁故障</p></li></ul><h2 id="各类问题的解决方法"><a href="#各类问题的解决方法" class="headerlink" title="各类问题的解决方法"></a>各类问题的解决方法</h2><h3 id="缓存穿透的常见策略"><a href="#缓存穿透的常见策略" class="headerlink" title="缓存穿透的常见策略"></a>缓存穿透的常见策略</h3><ul><li>参数校验：对请求参数(ID格式、范围)做校验，直接拒掉明显非法请求</li><li>布隆过滤器(Bloom filter)：把所有合法key(或大概率合法)放入Bloom Filter，查询前先校验(Bloom有误判但不漏报，可能拒绝掉一些合法键，但不会把不存在的当存在)。优点内存占用小，查询快；但需要维护(新增&#x2F;删除)和误判处理</li><li>缓存空结果：对于DB确认不存在的key，缓存一个空对象(或特殊值)但TTL设短(比如1-5分钟)，避免短时间内重复打DB。注意防止空值被缓存太长造成的错漏。</li><li>限流&#x2F;反爬虫：对频繁访问不存在key的请求进行限流或封禁IP</li></ul><h3 id="缓存击穿-单个key失效-解决"><a href="#缓存击穿-单个key失效-解决" class="headerlink" title="缓存击穿(单个key失效)解决"></a>缓存击穿(单个key失效)解决</h3><ul><li><p>互斥锁：当缓存miss时，只有一个请求去DB获取并重建缓存，其他请求等待&#x2F;返回旧值或轮询重试。实现方法：</p><ul><li>应用内singlefight(Go的singlefight包)——在单机实例内合并并发请求。</li><li>分布式情况下，用Redis的锁(SET NX)让单个实例去重建缓存</li></ul></li><li><p>永不过期&#x2F;极长TTL+后台异步刷新：把热点数据设置长TTL，并用后台任务周期刷新(适用于热点且变化不频繁的数据)</p></li><li><p>Stale-while-revalidate:返回过期前的旧值并异步刷新(对用户体验友好)</p></li></ul><p>伪代码(互斥锁重建)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">value=redis.get(key)</span><br><span class="line">if value!=nil:</span><br><span class="line">    return value</span><br><span class="line"></span><br><span class="line">if acquire_lock(&quot;lock:&quot;+key):</span><br><span class="line">    //double check,别重复查库</span><br><span class="line">    value = redis.get(key)</span><br><span class="line">    if value !=nil:</span><br><span class="line">        release_lock(...)</span><br><span class="line">        return value</span><br><span class="line">    value=db.get(key)</span><br><span class="line">    redis.set(key,value,ttl)</span><br><span class="line">    release_lock(...)</span><br><span class="line">    return value</span><br><span class="line">else:</span><br><span class="line">    //其他请求等待或短轮询，或直接返回适当错误</span><br><span class="line">    sleep(short)</span><br><span class="line">    goto try again</span><br></pre></td></tr></table></figure><h3 id="缓存雪崩-大面积失效-解决"><a href="#缓存雪崩-大面积失效-解决" class="headerlink" title="缓存雪崩(大面积失效)解决"></a>缓存雪崩(大面积失效)解决</h3><ul><li>TTL随机化：给不同key设置随机的TTL(例如base_ttl * (0.8~1.2))，避免同一时刻大量过期</li><li>缓存预热(Warm-up):上线&#x2F;重启&#x2F;版本切换后，主动把热点数据预先填入缓存。</li><li>多级缓存：第一层内存缓存(应用进程本地)，第二层Redis，减少瞬时Redis压力。若Redis宕机，第一层还能缓解短时间内压力。</li><li>降级与限流:流量激增时，服务降级(返回默认值&#x2F;静态页面)，或对DB进行限流保护。</li><li>扩容&#x2F;冗余：保证Redis集群有足够容量和高可用部署，避免单点故障。</li></ul><h2 id="实用示例"><a href="#实用示例" class="headerlink" title="实用示例"></a>实用示例</h2><h3 id="安全释放锁-必须用"><a href="#安全释放锁-必须用" class="headerlink" title="安全释放锁(必须用)"></a>安全释放锁(必须用)</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- release.Lua</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>,KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用(伪)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVALSHA &lt;sha1&gt; 1 lock:key &lt;clientId&gt;</span><br></pre></td></tr></table></figure><h3 id="获取锁带重试-伪Java"><a href="#获取锁带重试-伪Java" class="headerlink" title="获取锁带重试(伪Java)"></a>获取锁带重试(伪Java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:order:123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="type">long</span> ttl=<span class="number">10000</span>;<span class="comment">//ms</span></span><br><span class="line"><span class="type">long</span> waitTimeout=<span class="number">5000</span>;<span class="comment">//ms</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> end=System.currentTimeMillis()+waitTimeout;</span><br><span class="line"><span class="keyword">while</span>(System.currentTimeMillis()&lt;end)&#123;</span><br><span class="line">    String ok=jedis.set(lockKey,clientId,<span class="string">&quot;NX&quot;</span>,<span class="string">&quot;PX&quot;</span>,ttl);</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;OK&quot;</span>.equals(ok))&#123;</span><br><span class="line">        <span class="comment">//got Lock</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">50</span>);<span class="comment">//backoff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放用上面的Lua脚本(执行EVAL)</p><h3 id="缓存旁路-伪代码"><a href="#缓存旁路-伪代码" class="headerlink" title="缓存旁路(伪代码)"></a>缓存旁路(伪代码)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUser(id):</span><br><span class="line">    key = &quot;user:&quot;+id</span><br><span class="line">    value = redis.get(key)</span><br><span class="line">    if value != null:</span><br><span class="line">        return value</span><br><span class="line">    //miss</span><br><span class="line">    user = do.query(id)</span><br><span class="line">    if user == null:</span><br><span class="line">        redis.set(key,NULL_PLACEHOLDER,short_ttl)</span><br><span class="line">        return null</span><br><span class="line">    redis.set(key,serialize(user),normal_ttl)</span><br><span class="line">    return user</span><br></pre></td></tr></table></figure><h2 id="最佳实践清单"><a href="#最佳实践清单" class="headerlink" title="最佳实践清单"></a>最佳实践清单</h2><ul><li><p>缓存:</p><ul><li>使用<code>cache-aside</code>模式常见且灵活</li><li>对不存在的值缓存短期空值，避免穿透</li><li>热点key使用长TTL+异步刷新或<code>stale-while-revalidate</code></li><li>给TTL添加随机抖动，避免同化失效</li><li>监控命中率、evictions、内存、慢查询</li></ul></li><li><p>锁</p><ul><li>锁value必须唯一(UUID);释放时要校验value再DEL(Lua)</li><li>锁TTL选取合理；若需要更长，做安全续租</li><li>避免在锁中做长时间阻塞或外部调用</li><li>对强一致性需求高的场景，考虑etcd&#x2F;zookeeper</li></ul></li><li><p>Redis选型&#x2F;运维</p><ul><li>选择合适持久化(RDB&#x2F;AOF)与持久化策略</li><li>生产环境用Cluster&#x2F;哨兵&#x2F;Replica做高可用与扩容</li><li>设置<code>maxmemory</code>和合适<code>eviction policy</code></li><li>定期运行内存分析，避免大value(如把大对象拆成hash)</li></ul></li></ul><h2 id="常见问答"><a href="#常见问答" class="headerlink" title="常见问答"></a>常见问答</h2><h3 id="Redis锁能保证绝对安全吗？"><a href="#Redis锁能保证绝对安全吗？" class="headerlink" title="Redis锁能保证绝对安全吗？"></a>Redis锁能保证绝对安全吗？</h3><p>单实例+SET NX PX +Lua脚本能解决大部分问题，但在网络分区、客户端挂起(GC)或多实例复杂失败场景下仍有edge-case。需要严格一致性时选用Raft&#x2F;Paxos系统(etcd&#x2F;zookeeper)</p><h3 id="布隆过滤器会占用内存吗？误判怎么办？"><a href="#布隆过滤器会占用内存吗？误判怎么办？" class="headerlink" title="布隆过滤器会占用内存吗？误判怎么办？"></a>布隆过滤器会占用内存吗？误判怎么办？</h3><p>布隆滤器用很少表示海量key，误判率可通过位数组大小和hash函数数目调节。误判会把某些合法key误判为”可能存在”,需设计容错(短TTL)</p><h3 id="Redis单线程是不是性能瓶颈？"><a href="#Redis单线程是不是性能瓶颈？" class="headerlink" title="Redis单线程是不是性能瓶颈？"></a>Redis单线程是不是性能瓶颈？</h3><p>Redis单线程是命令处理单线程，I&#x2F;O使用multiplexing，单命令执行速度极快。瓶颈通常在网络、内存或慢命令(如复杂的<code>KEYS</code>)上</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些关于MySQL</title>
      <link href="/JasmineRain.github.io/2025/09/09/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8EMySQL/"/>
      <url>/JasmineRain.github.io/2025/09/09/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8EMySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL基础概念"><a href="#MySQL基础概念" class="headerlink" title="MySQL基础概念"></a>MySQL基础概念</h2><p>MySQL是一个关系型数据库管理系统(RDBMS)，它存储的数据是结构化的，使用表来存储信息，支持SQL(机构化查询语言)来操作数据</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>数据库</td><td>数据的集合</td></tr><tr><td>表</td><td>数据库中的具体存储机构</td></tr><tr><td>行</td><td>表中的一条记录</td></tr><tr><td>列</td><td>表的字段</td></tr><tr><td>主键</td><td>唯一标识一行记录</td></tr><tr><td>外键</td><td>关联另一张表的字段</td></tr><tr><td>索引</td><td>加速数据查询的工具</td></tr></tbody></table><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><p>数值类型</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>INT</td><td>整数</td></tr><tr><td>BIGINT</td><td>大整数</td></tr><tr><td>DECIMAL</td><td>精确小数</td></tr><tr><td>FLOAT&#x2F;DOUBLE</td><td>浮点数</td></tr></tbody></table><p>字符串类型</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>CHAR(n)</td><td>固定长度</td></tr><tr><td>VARCHAR(n)</td><td>可变长度</td></tr><tr><td>TEXT</td><td>长文本</td></tr></tbody></table><p>日期时间类型</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>DATE</td><td>日期(YYYY-MM-DD)</td></tr><tr><td>DATETIME</td><td>日期时间</td></tr><tr><td>TIMESTAMP</td><td>时间戳，自动记录修改时间</td></tr></tbody></table><h2 id="基本SQL操作"><a href="#基本SQL操作" class="headerlink" title="基本SQL操作"></a>基本SQL操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users (username,email,password)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Alice&#x27;</span>,<span class="string">&#x27;alice@example.com&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询指定列</span></span><br><span class="line"><span class="keyword">SELECT</span> username,email <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 条件查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模糊查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> email<span class="operator">=</span><span class="string">&#x27;alice_new@example.com&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>COUNT(*)</td><td>统计数量</td></tr><tr><td>SUM(column)</td><td>求和</td></tr><tr><td>AVG(column)</td><td>平均值</td></tr><tr><td>MAX(column)</td><td>最大值</td></tr><tr><td>MIN(column)</td><td>最小值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(id) <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> role,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> count</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> role</span><br><span class="line"><span class="keyword">HAVING</span> count <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设有orders表</span></span><br><span class="line"><span class="keyword">SELECT</span> users.username,order.amount</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span>order.user_id;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id FORM orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span><span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="索引和优化"><a href="#索引和优化" class="headerlink" title="索引和优化"></a>索引和优化</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>加快查询速度，但会占用额外空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_username <span class="keyword">ON</span> users(username);</span><br></pre></td></tr></table></figure><h3 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h3><ul><li>使用<code>WHERE</code>条件避免全表扫描</li><li>使用<code>LIMIT</code>限制查询数量</li><li>避免SELECT*,只选需要的列</li><li>定期<strong>优化表</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE <span class="keyword">TABLE</span> users;</span><br></pre></td></tr></table></figure><h2 id="事务和锁"><a href="#事务和锁" class="headerlink" title="事务和锁"></a>事务和锁</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务确保操作的<strong>原子性、一致性、隔离性、持久性(ACID)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;<span class="comment">-- 提交事务</span></span><br><span class="line"><span class="comment">-- ROLLBACK; --回滚事务</span></span><br></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>行锁：InnoDB支持，锁单行，适合高并发</li><li>表锁：MyISAM默认，锁整个表</li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><table><thead><tr><th>引擎</th><th>特点</th></tr></thead><tbody><tr><td>InnoDB</td><td>支持事务、行锁、外键</td></tr><tr><td>MyISAM</td><td>不支持事务、速度快，表锁</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    neme <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><blockquote><p>mysqldump -u root -p mudb &gt; mydb_backup.sql</p></blockquote><h3 id="恢复数据库"><a href="#恢复数据库" class="headerlink" title="恢复数据库"></a>恢复数据库</h3><blockquote><p>mysql -u root -p mydb &lt; mydb_backup.sql</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建一个简单的博客系统，用户表、文章表、评论表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> posts(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    user_id <span class="type">INT</span>,</span><br><span class="line">    title VERCHAR(<span class="number">100</span>),</span><br><span class="line">    content TEXT,</span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (user_id) <span class="keyword">REFERENCES</span> users(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> comments(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    post_id <span class="type">INT</span>,</span><br><span class="line">    user_id <span class="type">INT</span>,</span><br><span class="line">    content TEXT,</span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (post_id) <span class="keyword">REFERENCES</span> posts(id),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (user_id) <span class="keyword">REFERENCES</span> users(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="获取文章及评价"><a href="#获取文章及评价" class="headerlink" title="获取文章及评价"></a>获取文章及评价</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> posts.title,users.username,comments.content</span><br><span class="line"><span class="keyword">FROM</span> posts</span><br><span class="line"><span class="keyword">JOIN</span> comments <span class="keyword">ON</span> posts.id <span class="operator">=</span>comments.post_id</span><br><span class="line"><span class="keyword">JOIN</span> users <span class="keyword">ON</span> comments.user_id <span class="operator">=</span> users.id;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin-Echo</title>
      <link href="/JasmineRain.github.io/2025/09/08/Gin-Echo/"/>
      <url>/JasmineRain.github.io/2025/09/08/Gin-Echo/</url>
      
        <content type="html"><![CDATA[<h2 id="它们是什么"><a href="#它们是什么" class="headerlink" title="它们是什么"></a>它们是什么</h2><ul><li><p>Gin:轻量、性能导向、API风格接近Martini，但实现上更高性能(使用高效路由&#x2F;最小分配等)。适合需要高吞吐与中等复杂度的服务。以最少的开销+开发效率取胜</p></li><li><p>Echo:语言简洁、功能齐全、可拓展性好，内置很多中间件(CORS、JWT、静态、日志等)，上手快，适合快速构建REST服务。以完整性+可拓展性取胜</p></li></ul><h2 id="框架核心对比-要点"><a href="#框架核心对比-要点" class="headerlink" title="框架核心对比(要点)"></a>框架核心对比(要点)</h2><ul><li><p>路由:Gin使用高效的redix&#x2F;tree路由实现(零分配&#x2F;fast)，Echo也有高性能路由实现。两者在典型场景差异很小。</p></li><li><p>中间件链:两者都采用链式中间件(Request-&gt;中间件1-&gt;中间件2-&gt;Handler-&gt;返回)。中间件顺序很重要(认证放在路由前面、错误恢复放最外层等)</p></li><li><p>绑定与验证:Gin原生支持binding标签并在Bind时触发验证(内部使用go-playground&#x2F;validator);Echo通常配合go-playground&#x2F;validator，通过实现echo.Validator把验证接入。推荐统一使用github.com&#x2F;go-playground&#x2F;validator&#x2F;v10</p></li><li><p>模板、静态、文件上传、WebSocket:两者都支持模板渲染与静态文件;WebSocket通常用第三方(gorilla&#x2F;websocket)集成。</p></li><li><p>中小型服务最重要的点:错误处理和一致的JSON返回、鉴权&#x2F;权限、日志&#x2F;追踪、优雅关机。</p></li></ul><h2 id="简短代码示例对比"><a href="#简短代码示例对比" class="headerlink" title="简短代码示例对比"></a>简短代码示例对比</h2><p>Gin最常见的&#x2F;ping示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    r:=gin.Default()<span class="comment">//内置Logger+Recovery</span></span><br><span class="line">    r.Get(<span class="string">&quot;/ping&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">        c.JSON(http.StatusOK,gin.H&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;pong&quot;</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Echo等价的&#x2F;ping示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/labstack/echo/v4&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    e:=echo.New()<span class="comment">//默认Logger+Recovery可选</span></span><br><span class="line">    e.Get(<span class="string">&quot;/ping&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span></span><span class="type">error</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.JSON(http.StatusOK,<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;message&quot;</span>:<span class="string">&quot;pong&quot;</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    e.Start(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin </tag>
            
            <tag> Echo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/JasmineRain.github.io/2025/09/08/Dijkstra%E7%AE%97%E6%B3%95/"/>
      <url>/JasmineRain.github.io/2025/09/08/Dijkstra%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="它解决了什么问题"><a href="#它解决了什么问题" class="headerlink" title="它解决了什么问题"></a>它解决了什么问题</h2><p>在大多数最短路径问题中，Dijkstra算法是最常用的、效率最高的。它是一种“单源”最短路径的算法，一次计算能够得到从<strong>一个起点到其他所有点</strong>的最短距离长度、最短路径的途径点</p><p>输入为带权图G&#x3D;(V,E),边权非负(有负权边考虑Bellman-Ford&#x2F;SPFA&#x2F;Johnson)，给定起点，适用于有向图和无向图(无向图就加双向边)</p><h2 id="核心思想-贪心-松弛"><a href="#核心思想-贪心-松弛" class="headerlink" title="核心思想(贪心+松弛)"></a>核心思想(贪心+松弛)</h2><p>维护每个点的“目前已知最短距离”<code>dist[]</code>,反复从<strong>未确定</strong>的点里选出dist最小者u(用最小堆加速)，将它<strong>永久确定</strong>;然后用u去尝试”放松”所有出边(u,v,w):<br>如果<code>dist[v]&gt;dist[u]+w</code>，就更新之，并记录<code>parent[v]=u</code>以便还原路径</p><p>因为所有边权非负，当前dist最小的未确定点u再走任何边其代价只会增加，不可能通过未确定的其他点得到更短的代替路径，故一旦选出就最优(贪心选择性质)</p><h2 id="实现细节-邻接表-最小堆"><a href="#实现细节-邻接表-最小堆" class="headerlink" title="实现细节(邻接表+最小堆)"></a>实现细节(邻接表+最小堆)</h2><ul><li>数据结构:<code>adj[u]</code>存(v,w),<code>priority_queue</code>堆按<code>(dist,node)</code>升序</li><li>常量:<code>INF</code>取很大(如<code>4e18</code>),避免溢出</li><li>复杂度:用二叉堆:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((V+E)logV)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>、用Fibonacci堆(理论):<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mo>+</mo><mi>V</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E+VlogV)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>、稠密图用<strong>邻接矩阵+线性扫描</strong>:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>更简单</li></ul><h2 id="步骤示例"><a href="#步骤示例" class="headerlink" title="步骤示例"></a>步骤示例</h2><table><thead><tr><th>步骤</th><th>做法</th><th>具体操作</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>从起点s出发，用BFS扩展它的邻居节点</td><td>把这些邻居点放到一个集合A中，并记录这些点到s的距离</td><td></td></tr><tr><td>2</td><td>选择距离s最近的邻居v，继续用BFS扩展v的邻居</td><td>1. 在A中找到距离s最小的点v，把v的邻居点放到A中 2. 如果v的邻居经过v中转，到s的距离更短，则更新这些邻居到s的距离 3.从集合A中移走v，后面不再处理v</td><td>1.得到了从s到v的最短路径 2.v的邻居更新了到s的距离</td></tr><tr><td>3</td><td>重复步骤2，直到所有点都扩展到并计算完毕</td><td></td><td>集合A为空，计算出所有点到s的最短距离</td></tr></tbody></table><h2 id="C-模板-邻接表-最小堆，含路径还原"><a href="#C-模板-邻接表-最小堆，含路径还原" class="headerlink" title="C++模板(邻接表+最小堆，含路径还原)"></a>C++模板(邻接表+最小堆，含路径还原)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF=(<span class="type">long</span> <span class="type">long</span>)<span class="number">4e18</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n,m,s;<span class="comment">//顶点数n，边数m，起点s</span></span><br><span class="line">    <span class="keyword">if</span>(!(cin&gt;&gt;n&gt;&gt;m&gt;&gt;s))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt;<span class="built_in">adj</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);<span class="comment">//无向图则再adj[v].push_back(&#123;u,w&#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;<span class="built_in">dist</span>(n<span class="number">+1</span>,INF);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">parent</span>(n<span class="number">+1</span>,<span class="number">-1</span>);</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt;&gt;&gt;pq;</span><br><span class="line"></span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [du,u]=pq.<span class="built_in">top</span>();pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(du!=dist[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:adj[u])&#123;</span><br><span class="line">            <span class="type">int</span> v=e.to;<span class="type">long</span> <span class="type">long</span> nd=du+e.w;</span><br><span class="line">            <span class="keyword">if</span>(nd&lt;dist[v])&#123;</span><br><span class="line">                dist[v]=nd;</span><br><span class="line">                parent[v]=u;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;nd.v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出距离 不可达为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++&#123;</span><br><span class="line">        cout&lt;&lt;(dist[v]&gt;=INF/<span class="number">2</span>?<span class="number">-1</span>:dist[v])&lt;&lt;(v==n?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还原s-&gt;t的路径</span></span><br><span class="line">    <span class="type">int</span> t=n;</span><br><span class="line">    <span class="keyword">if</span>(dist[t]&gt;=INF/<span class="number">2</span>)&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;No path\n&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur=t;cur!=<span class="number">-1</span>;cur=parent[cur])</span><br><span class="line">            path.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(),path.<span class="built_in">end</span>());</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;Path:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:path)cerr&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;x;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用<code>long long</code>存边权与距离;<code>du!=dist[u]</code>过滤过期项<br>多组数据时记得清空容器与重置<code>dist/Parent</code><br>无向图要加双向边，有多条边时正常处理(选择更优)</p></blockquote><h2 id="Go模板-最小堆-路径还原"><a href="#Go模板-最小堆-路径还原" class="headerlink" title="Go模板(最小堆+路径还原)"></a>Go模板(最小堆+路径还原)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;container/heap&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span>&#123;</span><br><span class="line">    to <span class="type">int</span></span><br><span class="line">    w <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> INF <span class="type">int64</span>=<span class="number">4e18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span>&#123;</span><br><span class="line">    d <span class="type">int64</span> </span><br><span class="line">    v <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MinHeap []Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i,j <span class="type">int</span>) <span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[i].d&lt;h[j].d</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i,j <span class="type">int</span>)&#123;</span><br><span class="line">    h[i],h[j]=h[j],h[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;)&#123;</span><br><span class="line">    *h=<span class="built_in">append</span>(*h,x.(Item))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    old:=*h</span><br><span class="line">    x:=old[<span class="built_in">len</span>(old)<span class="number">-1</span>]</span><br><span class="line">    *h=old[:<span class="built_in">len</span>(old)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    in:=bufio.NewReader(os.Stdin)</span><br><span class="line">    out:=bufio.NewReader(os.Stdout)</span><br><span class="line">    <span class="keyword">defer</span> out.Flush()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> n,m,s <span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> _,err:=fmt.Fscan(in,&amp;n,&amp;m,&amp;s);err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adj:=<span class="built_in">make</span>([][]Edge,n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;m;i++&#123;</span><br><span class="line">        <span class="keyword">var</span> u,v <span class="type">int</span></span><br><span class="line">        <span class="keyword">var</span> w <span class="type">int64</span></span><br><span class="line">        fmt.Fscan(in,&amp;u,&amp;v,&amp;w)</span><br><span class="line">        adj[u]=<span class="built_in">append</span>(adj[u],Edge&#123;v,w&#125;)</span><br><span class="line">        <span class="comment">//无向图:adj[v]=append(adj[v],Edge&#123;u,w&#125;)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dist:=<span class="built_in">make</span>([]<span class="type">int64</span>,n+<span class="number">1</span>)</span><br><span class="line">    parent:=<span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++&#123;</span><br><span class="line">        dist[i]=INF</span><br><span class="line">        parent[i]=<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dist[s]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    h:=&amp;MinHeap&#123;&#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line">    heap.Push(h,Item&#123;<span class="number">0</span>,s&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> h.Len()&gt;<span class="number">0</span>&#123;</span><br><span class="line">        it:=heap.Pop(h).(Item)</span><br><span class="line">        du,u:=it.d,it.v</span><br><span class="line">        <span class="keyword">if</span> du!=dist[u]&#123;<span class="comment">//过期项</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _,e:=<span class="keyword">range</span> adj[u]&#123;</span><br><span class="line">            v:=e.to</span><br><span class="line">            nd:=du+e.w</span><br><span class="line">            <span class="keyword">if</span> nd&lt;dist[v]&#123;</span><br><span class="line">                dist[v]=nd</span><br><span class="line">                parent[v]=u</span><br><span class="line">                heap.Push(h,Item&#123;nd,v&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v:=<span class="number">1</span>;v&lt;=n;v++&#123;</span><br><span class="line">        <span class="keyword">if</span> dist[v]&gt;INF/<span class="number">2</span>&#123;</span><br><span class="line">            fmt.FPrint(out,<span class="number">-1</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fmt.Fprint(out,dist[v])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v&lt;n&#123;</span><br><span class="line">            fmt.Fprint(out,<span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprint(out)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还原路径</span></span><br><span class="line">    <span class="keyword">if</span> dist[n]&lt;INF/<span class="number">2</span>&#123;</span><br><span class="line">        path:=[]<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> cur:=n;cur!=<span class="number">-1</span>:cur=parent[cur]&#123;</span><br><span class="line">            path=<span class="built_in">append</span>(path,cur)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        <span class="keyword">for</span> i,j:=<span class="number">0</span>,<span class="built_in">len</span>(path)<span class="number">-1</span>;i&lt;j;i,j=i+<span class="number">1</span>,j<span class="number">-1</span>&#123;</span><br><span class="line">            path[i],path[j]=path[j],path[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印到标准错误 避免干扰测评输出</span></span><br><span class="line">        fmt.Fprint(os.Stderr,<span class="string">&quot;Path:&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> _,x:=<span class="keyword">range</span> path&#123;</span><br><span class="line">            fmt.Fprint(os.Stderr,<span class="string">&quot; &quot;</span>,x)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintln(os.Stderr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="稠密图的O-写法"><a href="#稠密图的O-写法" class="headerlink" title="稠密图的O()写法"></a>稠密图的O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)写法</h2><p>适合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>≈</mo><msup><mi>V</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E \approx V^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><ol><li><p><code>dist[s]=0</code>，其余<code>INF</code>全<code>false</code></p></li><li><p>循环<code>n</code>次：</p><ul><li>在线性扫描访问点中找<code>dist</code>最小的u，标记<code>vis[u]=true</code></li><li>用u松弛所有<code>v</code>:<code>dist[v]=min(dist[v],dist[u]+w[u][v])</code>复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li></ol><h2 id="常见坑"><a href="#常见坑" class="headerlink" title="常见坑"></a>常见坑</h2><ul><li>负权&#x2F;负环：dijkstra不适用，哪怕只有一条负边也不行</li><li>整型溢出:总全值可能很大，统一用64位整型</li><li>多组数据：注意初始化</li><li>不可达：输出-1等条件</li><li>双向边别忘了加两次：并行多边&#x2F;自环无序特判，不会影响正确性</li></ul><h2 id="进阶与变体"><a href="#进阶与变体" class="headerlink" title="进阶与变体"></a>进阶与变体</h2><ul><li>0-1 BFS：边权只取0&#x2F;1，用双端队列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></li><li>Dial’s Algorithm:非负小整数权(最大权C不大)可用桶实现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo>+</mo><mi>V</mi><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V+E+VC)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></li><li>多源最短路:把所有源点<code>dist=0</code>同时入堆</li><li>A*：有启发式的单源单目标更快，需要一致，可采纳的启发函数</li><li>K次最短路：在Dijkstra框架上记录到达次数</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
            <tag> cpp </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go的并发</title>
      <link href="/JasmineRain.github.io/2025/09/06/Go%E7%9A%84%E5%B9%B6%E5%8F%91/"/>
      <url>/JasmineRain.github.io/2025/09/06/Go%E7%9A%84%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>轻量级线程，goroutine是Go运行时(runtime)管理的协程，比操作系统线程更轻量</p><p>初始栈空间只有几kb，会按需自动增长</p><p>Go runtime提供M:N调度模型，N个Goroutine映射到M个操作系统线程</p><p>在函数调用前加<code>go</code>关键词启动</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(id <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Worker %d: %d\n&quot;</span>,id,i)</span><br><span class="line">        time.Sleep(time.Millisecond*<span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> work(<span class="number">1</span>) <span class="comment">//开启一个Goroutine</span></span><br><span class="line">    <span class="keyword">go</span> work(<span class="number">2</span>) <span class="comment">//再开一个Goroutine</span></span><br><span class="line">    time.Sleep(<span class="number">2</span>*time.Second)<span class="comment">//主协程等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel是Go提供的”通信管道”，用于在多个Goroutine之间传递数据</p><ul><li><p>安全:多Goroutine并发访问channel不需要额外加锁</p></li><li><p>阻塞:</p><ul><li>发送数据时，如果没有Goroutine接收，会阻塞</li><li>接收数据时，如果没有Goroutine发送，也会阻塞</li></ul></li></ul><p>声明与使用如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">2</span>)<span class="comment">//带缓冲区的channel，容量为2</span></span><br><span class="line">    ch&lt;<span class="number">-10</span></span><br><span class="line">    ch&lt;<span class="number">-20</span></span><br><span class="line">    fmt.Println(&lt;-ch)<span class="comment">//10</span></span><br><span class="line">    fmt.Println(&lt;-ch)<span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常见模式:<br>1.生产者-消费者模型<br>2.任务发布<br>3.同步信号</p></blockquote><hr><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>多路复用，<code>select</code>语句用来同时监听多个channel的操作，哪一个先准备好就执行哪一个分支</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch1:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    ch2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">        ch1&lt;-<span class="string">&quot;Hello from ch1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">        ch2&lt;-<span class="string">&quot;Hello from ch2&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++&#123;</span><br><span class="line">        <span class="keyword">select</span>&#123;</span><br><span class="line">            <span class="keyword">case</span> msg1:=&lt;-ch1:</span><br><span class="line">                fmt.Println(msg1)</span><br><span class="line">            <span class="keyword">case</span> msg2:&lt;-ch2:</span><br><span class="line">                fmt.Println(msg2)</span><br><span class="line">            <span class="keyword">case</span> &lt;-time.After(<span class="number">1500</span>*time.Millisecond):<span class="comment">//超时控制</span></span><br><span class="line">                fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>context是Go1.7引入的，用来在Goroutine之间传递取消信号、超时控制、元数据</p><p>常见函数:</p><ol><li><code>context.Background()</code>:根Context</li><li><code>context.WithCancel()</code>:手动取消</li><li><code>context.WithTimeout()</code>:超时自动取消</li><li><code>context.WithDeadline()</code>:设定截止时间</li><li><code>ctx.Done()</code>:返回一个channel，收到信号表示被取消</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        <span class="keyword">select</span>&#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                fmt.Println(<span class="string">&quot;worker stopped&quot;</span>,ctx.Err())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;working...&quot;</span>)</span><br><span class="line">                time.Sleep(<span class="number">500</span>*time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ctx,cancel:=context.WithTimeout(context.Background(),<span class="number">2</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="keyword">go</span> worker(ctx)</span><br><span class="line">    time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2秒后ctx自动取消,Goroutine停止</p><hr><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p>互斥锁用于保证同一时间只有一个Goroutine能访问共享资源</p><p>并发写共享资源会产生数据竞争，需要加锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    counter <span class="type">int</span></span><br><span class="line">    mu sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fun add(wg *sync.WaitGroup)&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++&#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        counter++</span><br><span class="line">        mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> add(&amp;wg)</span><br><span class="line">    <span class="keyword">go</span> add(&amp;wg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Final counter:&quot;</span>,counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO基础语法</title>
      <link href="/JasmineRain.github.io/2025/09/05/GO%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/JasmineRain.github.io/2025/09/05/GO%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>一个简单的helloworld程序的展示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>package main</code>定义程序包,main包可独立运行</li><li><code>import</code>导入包</li><li><code>func main()</code>程序入口</li><li><code>fmt.Println()</code>打印输出</li></ul><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> =<span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b=<span class="number">10</span></span><br><span class="line">c:=<span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi=<span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    Monday=<span class="number">1</span></span><br><span class="line">    Tuesday=<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>int&#x2F;int8&#x2F;int16&#x2F;int32&#x2F;int64</td><td>整型</td></tr><tr><td>uint&#x2F;uint8&#x2F;uint16&#x2F;uint32&#x2F;uint64</td><td>无符号整型</td></tr><tr><td>float32&#x2F;float64</td><td>浮点型</td></tr><tr><td>bool</td><td>布尔值</td></tr><tr><td>string</td><td>字符串</td></tr><tr><td>rune</td><td>Unicode字符(等价int32)</td></tr><tr><td>byte</td><td>uint8,常用于二进制处理</td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>算术运算:+ - * &#x2F; %</li><li>赋值运算:&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;</li><li>比较运算:&#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;</li><li>逻辑运算:&amp;&amp; || !</li></ul><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><ul><li>if&#x2F;else</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a&gt;b&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a&gt;b&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a&lt;=b&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> day&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Monday&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Tuesday&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Other&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for循环</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本形式</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似while</span></span><br><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i&lt;<span class="number">5</span>&#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无限循环</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="comment">//do...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>数组与切片</p></li><li><p>数组</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">int</span>=[<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>切片(可动态扩容)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">s=<span class="built_in">append</span>(s,<span class="number">4</span>)<span class="comment">//添加元素</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))<span class="comment">//长度</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s))<span class="comment">//容量</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;Alice&quot;</span>]=<span class="number">10</span></span><br><span class="line">m[<span class="string">&quot;Bob&quot;</span>]=<span class="number">20</span></span><br><span class="line"></span><br><span class="line">fmt.Println(m[<span class="string">&quot;Alice&quot;</span>])<span class="comment">//10</span></span><br><span class="line"><span class="built_in">delete</span>(m,<span class="string">&quot;Bob&quot;</span>)<span class="comment">//删除键</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a,b <span class="type">int</span>)</span></span>(<span class="type">int</span>,<span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> b,a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x,y:=swap(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>=&amp;a <span class="comment">//取地址</span></span><br><span class="line">fmt.Println(*p) <span class="comment">//解引用</span></span><br><span class="line">*p=<span class="number">20</span></span><br><span class="line">fmt.Println(a)<span class="comment">//20</span></span><br></pre></td></tr></table></figure><blockquote><p>Go支持指针，但不支持指针运算</p></blockquote><h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u:=User&#123;Name:<span class="string">&quot;Alice&quot;</span>,Age:<span class="number">20</span>&#125;</span><br><span class="line">fmt.Println(u.Name)</span><br></pre></td></tr></table></figure><ul><li>可定义方法</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span>SayHello()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello&quot;</span>,u.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span>&#123;</span><br><span class="line">    speak() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Speak() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a Animal=Dog&#123;&#125;</span><br><span class="line">fmt.Println(a.Speak())<span class="comment">//Wool!</span></span><br></pre></td></tr></table></figure><blockquote><p>Go接口是隐式实现，不需要显示继承</p></blockquote><h2 id="goroutine-channel-并发"><a href="#goroutine-channel-并发" class="headerlink" title="goroutine+channel 并发"></a>goroutine+channel 并发</h2><p>goroutine</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello from goroutine&quot;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch&lt;<span class="number">-10</span> <span class="comment">//发送数据</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">val :=&lt;-ch <span class="comment">//接收数据</span></span><br><span class="line">fmt.Println(val) <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>select</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> mag:=&lt;-ch1:</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    <span class="keyword">case</span> ch2&lt;<span class="number">-20</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Sent 20&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;No communication&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>goroutine+channel是go的核心并发模型，适合做高并发服务</p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a,b <span class="type">int</span>)</span></span>(<span class="type">int</span>,<span class="type">error</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> b==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>,fmt.Println(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a/b,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res,err:=div(<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go不用try&#x2F;catch，而是返回error</p></blockquote><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init myproject</span><br><span class="line"><span class="keyword">go</span> mod tidy <span class="comment">//自动下载依赖</span></span><br></pre></td></tr></table></figure><blockquote><p>每个项目独立模块，方便依赖管理</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Segment tree</title>
      <link href="/JasmineRain.github.io/2025/08/19/Segment-tree/"/>
      <url>/JasmineRain.github.io/2025/08/19/Segment-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><p>线段树是主要用来维护<strong>区间信息</strong>的数据结构<br>线段树可以在O(logN)的时间复杂度内实现单点修改、区间修改、区间查询(区间求和、求区间最大值、求区间最小值)等操作</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>将数组<code>a=&#123;10,11,12,13,14&#125;</code>转化为线段树:设线段树的根节点编号为1，用数组d来保存我们的线段树,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>用来保存线段树上编号为i的节点的值，这里每个节点所维护的值就是这个节点所表示的区间总和。</p><p><img src="/JasmineRain.github.io/./Segment-tree/SegmentTree001.png" alt="线段树的形态"></p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的左儿子节点就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mn>2</mn><mo>∗</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{2*i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的右儿子节点就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">d_{2*i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>.如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示的是区间[s,t](即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">a_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{s+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>+...+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">a_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)的话，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的左儿子节点表示的是区间[s,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1696em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8246em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>],<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的右儿子表示的区间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mo>+</mo><mi>t</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{s+t}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1696em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8246em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>+1到t的闭区间<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>在实现时，我们考虑递归建树。设当前的根节点为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>,如果根节点管辖的区间长度已经是1,则可以直接根据<code>a</code>数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。</p><ul><li>c++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">  <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">    d[p] = a[s];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 移位运算符的优先级小于加减法，所以加上括号</span></span><br><span class="line">  <span class="comment">// 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围</span></span><br><span class="line">  <span class="built_in">build</span>(s, m, p * <span class="number">2</span>), <span class="built_in">build</span>(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>python</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">s, t, p</span>):</span><br><span class="line">    <span class="comment"># 对 [s,t] 区间建立线段树,当前根的编号为 p</span></span><br><span class="line">    <span class="keyword">if</span> s == t:</span><br><span class="line">        d[p] = a[s]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    m = s + ((t - s) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 移位运算符的优先级小于加减法，所以加上括号</span></span><br><span class="line">    <span class="comment"># 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围</span></span><br><span class="line">    build(s, m, p * <span class="number">2</span>)</span><br><span class="line">    build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 递归对左右区间建树</span></span><br><span class="line">    d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li>golang</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设数组 a 和线段树数组 d 已经定义</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> d []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(s, t, p <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 对 [s,t] 区间建立线段树，当前根的编号为 p</span></span><br><span class="line">    <span class="keyword">if</span> s == t &#123;</span><br><span class="line">        d[p] = a[s]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m := s + ((t - s) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">    build(s, m, p*<span class="number">2</span>)</span><br><span class="line">    build(m+<span class="number">1</span>, t, p*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    d[p] = d[p*<span class="number">2</span>] + d[p*<span class="number">2</span>+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 示例</span></span><br><span class="line">    a = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 下标从 1 开始</span></span><br><span class="line">    d = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>*<span class="built_in">len</span>(a))</span><br><span class="line">    build(<span class="number">1</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] a; <span class="comment">// 原数组，下标从 1 开始</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] d; <span class="comment">// 线段树数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="comment">// 对 [s,t] 区间建立线段树，当前根的编号为 p</span></span><br><span class="line">        <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">            d[p] = a[s];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">        build(s, m, p * <span class="number">2</span>);</span><br><span class="line">        build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        d[p] = d[p * <span class="number">2</span>] + d[p * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 下标从 1 开始</span></span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * a.length];</span><br><span class="line">        build(<span class="number">1</span>, a.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != <span class="number">0</span>) System.out.print(val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于线段树的空间:如果采用堆式存储,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>p</mi></mrow><annotation encoding="application/x-tex">2p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal">p</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>的左儿子,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2p+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>的右儿子,若有<code>n</code>个叶子节点,则<code>d</code>数组的范围最大为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">⌉</mo><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{\lceil log_n \rceil +1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">⌉</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>容易知道线段树的深度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil log_n \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">⌉</span></span></span></span>的，则在堆式存储情况下叶子节点(包括无用的叶子节点)数量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo fence="true">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">⌉</mo></mrow></msup></mrow><annotation encoding="application/x-tex">2^{\left\lceil\log{n}\right\rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span></span></span></span></span></span></span></span></span></span></span></span>个，又由于其为一棵完全二叉树，则其总节点个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mrow><mo fence="true">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{\left\lceil\log{n}\right\rceil+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1。当然如果你懒得计算的话可以直接把数组长度设为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">4n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span></span></span></span>，因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msup><mn>2</mn><mrow><mrow><mo fence="true">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{2^{\left\lceil\log{n}\right\rceil+1}-1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4157em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0707em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667em;"><span style="top:-2.9667em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5357em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="mspace mtight" style="margin-right:0.2453em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的最大值在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mi>x</mi></msup><mo>+</mo><mn>1</mn><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><msub><mi>N</mi><mo lspace="0em" rspace="0em">+</mo></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=2^{x}+1(x\in N_{+})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>时取到，此时节点数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mrow><mo fence="true">⌈</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo fence="true">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><msup><mn>2</mn><mrow><mi>x</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>4</mn><mi>n</mi><mo>−</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">2^{\left\lceil\log{n}\right\rceil+1}-1=2^{x+2}-1=4n-5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span></p></blockquote><p>而堆式存储存在无用的叶子节点，可以考虑使用内存池管理线段树节点，每当需要新建节点时从池中获取。自底向上考虑，必有每两个底层节点合并为一个上层节点，因此可以类似哈夫曼树地证明，如果有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个叶子节点，这样的线段树总共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个节点。其空间效率优于堆式存储，并且是可能的最优情况</p><p>这样的线段树可以自底向上维护</p><h2 id="线段树的区间查询"><a href="#线段树的区间查询" class="headerlink" title="线段树的区间查询"></a>线段树的区间查询</h2><p>区间查询，比如求区间[l,r]的总和(即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>+…+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">a_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)、求区间最大值&#x2F;最小值等操作</p><ul><li>cpp</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)</span><br><span class="line">    <span class="keyword">return</span> d[p];  <span class="comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">  <span class="type">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>), sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum += <span class="built_in">getsum</span>(l, r, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子</span></span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span>(l, r, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>python</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getsum</span>(<span class="params">l, r, s, t, p</span>):</span><br><span class="line">    <span class="comment"># [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span></span><br><span class="line">    <span class="keyword">if</span> l &lt;= s <span class="keyword">and</span> t &lt;= r:</span><br><span class="line">        <span class="keyword">return</span> d[p]  <span class="comment"># 当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">    m = s + ((t - s) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> l &lt;= m:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + getsum(l, r, s, m, p * <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子</span></span><br><span class="line">    <span class="keyword">if</span> r &gt; m:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + getsum(l, r, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><ul><li>golang</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// d 是全局数组，存储线段树节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getsum</span><span class="params">(l, r, s, t, p <span class="type">int</span>, d []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span></span><br><span class="line">    <span class="keyword">if</span> l &lt;= s &amp;&amp; t &lt;= r &#123;</span><br><span class="line">        <span class="keyword">return</span> d[p] <span class="comment">// 当前区间为询问区间的子集时直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    m := s + ((t - s) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> l &lt;= m &#123;</span><br><span class="line">        sum += getsum(l, r, s, m, p*<span class="number">2</span>, d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r &gt; m &#123;</span><br><span class="line">        sum += getsum(l, r, m+<span class="number">1</span>, t, p*<span class="number">2</span>+<span class="number">1</span>, d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] d; <span class="comment">// 存储线段树节点的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">int</span>[size * <span class="number">4</span>]; <span class="comment">// 足够容纳线段树节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getsum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> d[p]; <span class="comment">// 当前区间为询问区间的子集时直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">            sum += getsum(l, r, s, m, p * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) &#123;</span><br><span class="line">            sum += getsum(l, r, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStruct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> segment tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux common commands</title>
      <link href="/JasmineRain.github.io/2025/08/19/Linux-common-commands/"/>
      <url>/JasmineRain.github.io/2025/08/19/Linux-common-commands/</url>
      
        <content type="html"><![CDATA[<h2 id="文件与目录操作"><a href="#文件与目录操作" class="headerlink" title="文件与目录操作"></a>文件与目录操作</h2><p>ls -lh<br>以人类可读方式显示文件大小</p><p>ls -ltr<br>按时间排序</p><p>cd -<br>返回上一个目录</p><p>tree<br>树型结构显示目录，需要安装</p><p>stat file<br>查看文件详细信息</p><p>basename &#x2F;path&#x2F;file.txt<br>获取文件名</p><p>dirname &#x2F;path&#x2F;file.txt<br>获取文件路径</p><h2 id="文件查看与处理"><a href="#文件查看与处理" class="headerlink" title="文件查看与处理"></a>文件查看与处理</h2><p>cat -n file<br>显示行号</p><p>tac file<br>反向输出文件</p><p>less -N file<br>分页并显示行号</p><p>strings file<br>提取二进制文件中的字符串</p><p>split -l 1000 big.txt part_<br>按行切割文件</p><p>sort file<br>排序</p><p>uniq file<br>去重</p><p>diff file1 file2<br>比较两个文件</p><p>cmp file1 file2<br>比较两个文件是否相同</p><h2 id="权限与用户管理"><a href="#权限与用户管理" class="headerlink" title="权限与用户管理"></a>权限与用户管理</h2><p>chmod 644 file<br>rw-r–r–</p><p>chmod u+x file<br>给用户添加执行权限</p><p>umask<br>查看默认权限掩码</p><p>chgrp group file<br>修改文件所属组</p><p>groups user<br>查看用户所属组</p><p>useradd newuser<br>添加用户</p><p>usermod -aG sudo u<br>将用户加入sudo组</p><p>userdel -r user<br>删除用户及家目录</p><p>groupadd dev<br>新建用户组</p><h2 id="系统信息与硬件"><a href="#系统信息与硬件" class="headerlink" title="系统信息与硬件"></a>系统信息与硬件</h2><p>uname -r<br>查看内核版本</p><p>cat &#x2F;etc&#x2F;os-release<br>系统版本信息</p><p>hostnamectl<br>查看主机信息</p><p>uptime -p<br>只显示运行时长</p><p>lsblk<br>显示磁盘挂载</p><p>blkid<br>查看磁盘 UUID</p><p>mount &#x2F;dev&#x2F;sdb1 &#x2F;mnt<br>挂载磁盘</p><p>umount &#x2F;mnt<br>卸载磁盘</p><p>lscpu<br>CPU 信息</p><p>lsusb<br>USB 设备</p><p>lspci<br>PCI 设备</p><h2 id="进程与任务管理"><a href="#进程与任务管理" class="headerlink" title="进程与任务管理"></a>进程与任务管理</h2><p>ps -ef | grep ssh<br>查找进程</p><p>pgrep -u user<br>查看用户进程 PID</p><p>kill -15 1234<br>优雅终止进程</p><p>kill -9 1234<br>强制终止</p><p>pkill nginx<br>杀死 nginx 进程</p><p>top -u user<br>查看用户进程</p><p>htop<br>更友好的进程监控</p><p>jobs<br>后台任务</p><p>fg %1<br>任务恢复前台</p><p>bg %1<br>后台继续运行</p><h2 id="磁盘与文件系统"><a href="#磁盘与文件系统" class="headerlink" title="磁盘与文件系统"></a>磁盘与文件系统</h2><p>df -Th<br>查看磁盘文件系统类型</p><p>du -sh *<br>查看当前目录下文件大小</p><p>ls -lh &#x2F;var&#x2F;log<br>查看日志大小</p><p>ncdu<br>图形化磁盘分析工具（需安装）</p><p>fsck &#x2F;dev&#x2F;sdb1<br>检查文件系统</p><p>mount -o remount,rw &#x2F;<br>重新挂载为可写</p><h2 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h2><p>tar -cvf a.tar dir&#x2F;<br>打包</p><p>tar -xvf a.tar<br>解包</p><p>tar -czvf a.tar.gz dir<br>打包并压缩</p><p>tar -xzvf a.tar.gz<br>解压缩</p><p>zip -r a.zip dir&#x2F;<br>压缩 zip</p><p>unzip a.zip -d dir&#x2F;<br>解压到目录</p><p>xz -z file<br>压缩为 .xz</p><p>xz -d file.xz<br>解压</p><h2 id="网络与传输"><a href="#网络与传输" class="headerlink" title="网络与传输"></a>网络与传输</h2><p>ping -c 4 baidu.com<br>ping 4 次</p><p>curl -I <a href="http://url/">http://url</a><br>查看响应头</p><p>curl -O <a href="http://url/file">http://url/file</a><br>下载文件</p><p>wget -c <a href="http://url/file">http://url/file</a><br>断点续传下载</p><p>scp file user@ip:&#x2F;dir&#x2F;<br>上传文件</p><p>scp user@ip:&#x2F;dir&#x2F;file .&#x2F;<br>下载文件</p><p>rsync -avz src&#x2F; dest&#x2F;<br>高效同步文件</p><p>ssh user@ip<br>远程登录</p><p>ssh -p 2222 user@ip<br>指定端口</p><h2 id="网络管理与排错"><a href="#网络管理与排错" class="headerlink" title="网络管理与排错"></a>网络管理与排错</h2><p>ifconfig<br>查看网卡信息（旧）</p><p>ip addr show<br>查看网卡信息（推荐）</p><p>ip route<br>查看路由表</p><p>netstat -tulnp<br>查看端口</p><p>ss -lntp<br>新版端口查看</p><p>traceroute baidu.com<br>路由跟踪</p><p>dig baidu.com<br>DNS 解析</p><p>nslookup baidu.com<br>DNS 查询</p><p>telnet ip port<br>测试端口连通性</p><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="Ubuntu-Debian系"><a href="#Ubuntu-Debian系" class="headerlink" title="Ubuntu&#x2F;Debian系"></a>Ubuntu&#x2F;Debian系</h3><p>apt update<br>apt upgrade<br>apt install pkg<br>apt remove pkg<br>dpkg -i file.deb<br>安装本地包</p><h3 id="CentOS-RedHat系"><a href="#CentOS-RedHat系" class="headerlink" title="CentOS&#x2F;RedHat系"></a>CentOS&#x2F;RedHat系</h3><p>yum install pkg<br>yum remove pkg<br>yum update<br>rpm -ivh file.rpm<br>安装本地包</p><h2 id="日志与系统监控"><a href="#日志与系统监控" class="headerlink" title="日志与系统监控"></a>日志与系统监控</h2><p>journalctl -xe<br>查看系统日志</p><p>tail -f &#x2F;var&#x2F;log&#x2F;syslog<br>实时日志</p><p>tail -f &#x2F;var&#x2F;log&#x2F;messages<br>last<br>登录历史</p><p>w<br>登录用户及进程</p><p>uptime<br>系统负载</p><p>vmstat 2<br>每 2 秒显示内存&#x2F;CPU</p><p>iostat -x 1<br>磁盘 IO</p><p>sar -u 1 10<br>CPU 性能监控</p><h2 id="Shell快捷与工具"><a href="#Shell快捷与工具" class="headerlink" title="Shell快捷与工具"></a>Shell快捷与工具</h2><p>!!<br>执行上一条命令</p><p>!ls<br>执行最近的 ls 命令</p><p>history | grep xx<br>搜索历史命令</p><p>alias ll&#x3D;’ls -l’<br>设置别名</p><p>unalias ll<br>删除别名</p><p>echo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>A</mi><mi>T</mi><mi>H</mi></mrow><annotation encoding="application/x-tex">PATH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>查看环境变量</p><p>export VAR&#x3D;123<br>设置环境变量</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to use git</title>
      <link href="/JasmineRain.github.io/2025/08/18/How-to-use-git/"/>
      <url>/JasmineRain.github.io/2025/08/18/How-to-use-git/</url>
      
        <content type="html"><![CDATA[<h2 id="本地开发阶段"><a href="#本地开发阶段" class="headerlink" title="本地开发阶段"></a>本地开发阶段</h2><h3 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h3><ul><li><p>git init<br>初始化本地仓库</p></li><li><p>git clone &lt; repo &gt;<br>克隆远程仓库</p></li><li><p>git remote -v<br>查看远程仓库地址</p></li><li><p>git remote add origin &lt; url &gt;<br>添加远程仓库地址</p></li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li><p>git branch<br>查看分支</p></li><li><p>git branch dev<br>创建分支</p></li><li><p>git checkout dev&#x2F;git switch dev<br>切换分支</p></li><li><p>git checkout -b feature-x<br>新建并切换分支</p></li><li><p>git branch -d branch-name<br>删除本地分支</p></li><li><p>git branch -vv<br>查看本地分支与远程分支的关系</p></li></ul><h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><ul><li><p>git status<br>查看修改状态</p></li><li><p>git diff<br>查看改动内容</p></li><li><p>git add file<br>添加到暂存区</p></li><li><p>git add .<br>添加全部修改</p></li><li><p>git commit -m “feat:xxx”<br>提交代码</p></li><li><p>git commit –amend<br>修改最近一次commit</p></li><li><p>git restore file<br>撤销修改</p></li><li><p>git reset –hard HEAD<br>撤销到最后一次提交</p></li></ul><h2 id="与远程仓库交互"><a href="#与远程仓库交互" class="headerlink" title="与远程仓库交互"></a>与远程仓库交互</h2><h3 id="拉取更新"><a href="#拉取更新" class="headerlink" title="拉取更新"></a>拉取更新</h3><ul><li><p>git fetch<br>获取远程更新但不合并</p></li><li><p>git pull<br>获取远程更新并合并</p></li><li><p>git pull –rebase<br>获取远程更新并rebase</p></li></ul><h3 id="推送代码"><a href="#推送代码" class="headerlink" title="推送代码"></a>推送代码</h3><ul><li><p>git push origin dev<br>推送分支</p></li><li><p>git push -u origin dev<br>第一次推送并建立跟踪关系</p></li><li><p>git push –force<br>强制推送</p></li></ul><h3 id="远程分支管理"><a href="#远程分支管理" class="headerlink" title="远程分支管理"></a>远程分支管理</h3><ul><li><p>git branch -r<br>查看远程分支</p></li><li><p>git push origin –delete branch_name<br>删除远程分支</p></li><li><p>git fetch -p<br>清理本地已删除的远程分支</p></li></ul><h2 id="协作开发"><a href="#协作开发" class="headerlink" title="协作开发"></a>协作开发</h2><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul><li><p>git merge dev<br>合并分支</p></li><li><p>gti merge –no-ff dev<br>保留分支记录</p></li><li><p>git merge –squash dev<br>合并为一个commit</p></li></ul><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>发生冲突时git会标记&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD … &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; … &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>修改后git add file &amp;&amp; gti commit</p><h3 id="变基rebase"><a href="#变基rebase" class="headerlink" title="变基rebase"></a>变基rebase</h3><ul><li><p>git rebase main<br>把当前分支基于main更新</p></li><li><p>git rebase -i HEAD~3<br>交互式rebase(压缩、修改commit)</p></li></ul><h3 id="临时保存"><a href="#临时保存" class="headerlink" title="临时保存"></a>临时保存</h3><ul><li><p>git stash<br>存储未提交的修改</p></li><li><p>git stash pop<br>恢复修改</p></li><li><p>git stash list<br>查看存储列表</p></li></ul><h2 id="提交规范与历史管理"><a href="#提交规范与历史管理" class="headerlink" title="提交规范与历史管理"></a>提交规范与历史管理</h2><h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h3><ul><li><p>git log<br>查看提交日志</p></li><li><p>git log –oneline  –graph<br>简洁图形化日志</p></li><li><p>git blame file<br>查看文件每一行的修改者</p></li></ul><h3 id="撤销-恢复"><a href="#撤销-恢复" class="headerlink" title="撤销&#x2F;恢复"></a>撤销&#x2F;恢复</h3><ul><li><p>git revert commit_id<br>回滚某个提交(生成新提交)</p></li><li><p>git reset –hard commit_id<br>回退到某个提交(破坏性)</p></li><li><p>git checkout commit_id file<br>恢复某个文件到历史版本</p></li></ul><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><ul><li><p>git tag v1.0.0<br>打标签</p></li><li><p>gti push origin v1.0.0<br>推送标签</p></li><li><p>git tag  -d v1.0.0<br>删除本地标签</p></li><li><p>git push origin –delete v1.0.0<br>删除远程标签</p></li></ul><h2 id="团队协作中的高级用法"><a href="#团队协作中的高级用法" class="headerlink" title="团队协作中的高级用法"></a>团队协作中的高级用法</h2><h3 id="代码评审"><a href="#代码评审" class="headerlink" title="代码评审"></a>代码评审</h3><ul><li><p>在 GitHub&#x2F;GitLab 上提交 Pull Request (PR) &#x2F; Merge Request (MR)</p></li><li><p>代码合并前需要 Review</p></li></ul><h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><ul><li><p>git submodule add &lt; repo &gt;<br>引入子模块</p></li><li><p>git submodule update –init –recursive<br>更新子模块</p></li></ul><h3 id="多远程仓库"><a href="#多远程仓库" class="headerlink" title="多远程仓库"></a>多远程仓库</h3><ul><li><p>git remote add upstream &lt; url &gt;<br>添加上游仓库</p></li><li><p>git fetch upstream<br>获取上游更新</p></li><li><p>git rebase upstream&#x2F;main<br>同步上游改动</p></li></ul><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><ul><li><p>pre-commit<br>提交前检查代码格式</p></li><li><p>pre-push<br>推送前运行测试</p></li><li><p>commit-msg<br>检查 commit message 格式</p></li></ul><h2 id="常见场景总结"><a href="#常见场景总结" class="headerlink" title="常见场景总结"></a>常见场景总结</h2><p>拉代码<code>git pull</code><br>开新分支开发<code>git checkout -b feature-xxx</code><br>开发中提交<code>git add . &amp;&amp; git commit -m &quot;feat:xxx&quot;</code><br>推送分支<code>git push origin feature-xxx</code><br>合并代码提交PR&#x2F;MR，由leader审核<br>解决冲突，手动修改后<code>git add &amp;&amp; git commit</code><br>回退代码<code>git revert</code><br>多人协作,每天先<code>git pull --rebase</code>避免冲突</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis&#39;s data type</title>
      <link href="/JasmineRain.github.io/2025/08/18/Redis-s-data-type/"/>
      <url>/JasmineRain.github.io/2025/08/18/Redis-s-data-type/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h2><p>基本的数据存储单元，可以存储字符串、整数或者浮点数<br>string类型是二进制安全的。redis的string可以包含任何数据，比如jpg图片或者序列化的对象<br>string类型是redis最基本的数据类型，string类型的值最大能存储512mb</p><h3 id="string常用命令"><a href="#string常用命令" class="headerlink" title="string常用命令"></a>string常用命令</h3><ul><li>SET key value:设置键的值</li><li>GET key:获取键的值</li><li>INCR key:将键的值加1</li><li>DECR key:将键的值减1</li><li>APPEND key value:将值追加到键的值之后</li></ul><h2 id="哈希hash"><a href="#哈希hash" class="headerlink" title="哈希hash"></a>哈希hash</h2><p>一个键值对集合，可以存储多个字段<br>redis hash是一个键值对集合，类似于一个小型的noSQL数据库<br>redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象<br>每个哈希最多可以存储2^32-1个键值对</p><h3 id="hash常用命令"><a href="#hash常用命令" class="headerlink" title="hash常用命令"></a>hash常用命令</h3><ul><li>HSET key field value:设置哈希表中字段的值</li><li>HGET key field:获取哈希表中字段的值</li><li>HGETALL key:获取哈希表中所有字段和值</li><li>HDEL key field:删除哈希表中的一个或多个字段</li></ul><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><p>一个简单的列表，可以存储一系列的字符串元素<br>redis列表是最简单的字符串列表，按照插入顺序排序<br>列表最多可以存储2^32-1个元素</p><h3 id="list常用命令"><a href="#list常用命令" class="headerlink" title="list常用命令"></a>list常用命令</h3><ul><li>LPUSH key value:将值插入到列表头部</li><li>RPUSH key value:将值插入到列表尾部</li><li>LPOP key:移出并获取列表的第一个元素</li><li>RPOP key:移出并获取列表的最后一个元素</li><li>LRANGE key start stop:获取列表在指定范围(start-stop)内的元素</li></ul><h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>一个无序集合，可以存储不重复的字符串元素<br>redis的set是string类型的无序集合<br>集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)</p><h3 id="set常用命令"><a href="#set常用命令" class="headerlink" title="set常用命令"></a>set常用命令</h3><ul><li>SADD key value:向集合添加一个或多个成员</li><li>SREM key value:移除集合中的一个或多个成员</li><li>SMEMBERS key:返回集合中的所有成员</li><li>SISMEMBER key value:判断是否是集合的成员</li></ul><h2 id="有序集合sorted-set"><a href="#有序集合sorted-set" class="headerlink" title="有序集合sorted set"></a>有序集合sorted set</h2><p>类似于集合，但是每个元素都有一个分数score与之关联<br>redis zset和set一样也是string类型元素的集合，且不允许重复的成员<br>不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序<br>zset的成员是唯一的，但分数却可以重复</p><h3 id="sorted-zset常用命令"><a href="#sorted-zset常用命令" class="headerlink" title="sorted zset常用命令"></a>sorted zset常用命令</h3><ul><li>ZADD key score value:向有序集合添加一个或多个成员，或更新已存在成员的分数</li><li>ZRANGE key start stop [WITHSCORES]:返回指定范围内的成员</li><li>ZREM key value:移除有序集合中的一个或多个成员</li><li>ZSCORE key value:返回有序集合中，成员的分数值</li></ul><h2 id="位图-Bitmaps"><a href="#位图-Bitmaps" class="headerlink" title="位图 Bitmaps"></a>位图 Bitmaps</h2><p>基于字符串类型，可以对每个位进行操作<br>位数组，可以对字符串进行位操作<br>常用于实现布隆过滤器等位操作</p><h2 id="超日志-HyperLogLogs"><a href="#超日志-HyperLogLogs" class="headerlink" title="超日志 HyperLogLogs"></a>超日志 HyperLogLogs</h2><p>用于基数统计，可以估算集合中的唯一元素数量</p><h2 id="地理空间Geospatial"><a href="#地理空间Geospatial" class="headerlink" title="地理空间Geospatial"></a>地理空间Geospatial</h2><p>用于存储地理位置信息<br>支持地理空间索引和半径查询</p><h2 id="发布-订阅Pub-Sub"><a href="#发布-订阅Pub-Sub" class="headerlink" title="发布&#x2F;订阅Pub&#x2F;Sub"></a>发布&#x2F;订阅Pub&#x2F;Sub</h2><p>一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息</p><h2 id="流Streams"><a href="#流Streams" class="headerlink" title="流Streams"></a>流Streams</h2><p>用于消息队列和日志存储，支持消息的持久化和时间排序</p><h2 id="模块Modules"><a href="#模块Modules" class="headerlink" title="模块Modules"></a>模块Modules</h2><p>redis支持动态加载模块，可以拓展redis的功能</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge sort</title>
      <link href="/JasmineRain.github.io/2025/08/18/Merge-sort/"/>
      <url>/JasmineRain.github.io/2025/08/18/Merge-sort/</url>
      
        <content type="html"><![CDATA[<p>归并排序适合处理大规模数据排序，尤其是当需要稳定排序时非常有用</p><h2 id="归并排序原理"><a href="#归并排序原理" class="headerlink" title="归并排序原理"></a>归并排序原理</h2><ol><li>分治Divide，将数组从中间分成两半</li><li>解决conquer，递归地对左右两半分别进行归并排序</li><li>合并combine，将两个已排序的子数组合并成一个有序数组</li></ol><ul><li>时间复杂度：O(n logn)</li><li>空间复杂度：O(n)，需要额外数组用于合并</li><li>稳定排序，相同元素的相对顺序保持不变</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mid := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line">    left := mergeSort(arr[:mid])</span><br><span class="line">    right := mergeSort(arr[mid:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, left[i])</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, right[j])</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, left[i:]...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, right[j:]...)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">    sorted := mergeSort(arr)</span><br><span class="line">    fmt.Println(sorted) <span class="comment">// [1 2 3 4 5 6]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        mergeSortHelper(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSortHelper</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSortHelper(arr, left, mid);</span><br><span class="line">        mergeSortHelper(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) temp[k++] = arr[i++];</span><br><span class="line">            <span class="keyword">else</span> temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; temp.length; p++) arr[left + p] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        mergeSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Merge sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How is data sorting implemented in MySQL?</title>
      <link href="/JasmineRain.github.io/2025/08/18/How-is-data-sorting-implemented-in-MySQL/"/>
      <url>/JasmineRain.github.io/2025/08/18/How-is-data-sorting-implemented-in-MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><p>排序过程中，如果排序字段命中索引，则利用<strong>索引排序</strong><br>反之，使用<strong>文件排序</strong><br>文件排序中，如果数据量少则在内存中排序，具体是使用单路排序或者双路排序<br>如果数据大则利用磁盘文件进行外部排序，一般使用归并排序</p><h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><p>MySQL可以分为索引排序和filesort</p><h3 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h3><p>如果查询中的ORDER BY子句包含的字段已经在索引中，并且索引的排列顺序和ORDER BY子句一致，则可直接利用索引进行排序。这种方式效率高，因为索引有序。</p><h3 id="filesort"><a href="#filesort" class="headerlink" title="filesort"></a>filesort</h3><p>当使用explain分析SQL发现执行计划的extra中包含using filesort的时候，说明它无法应用索引的顺序，而主动排序了。</p><p>如果需要<strong>排序的数据比较少</strong>，则直接在内存中通过<code>sort_buffer</code>就能排了。具体是通过<code>sort_buffer_size</code>参数来控制<code>sort_buffer</code>的大小，如果需要排序的数据量小于<code>sort_buffer</code>则直接在内存中排序，反之需要利用磁盘临时文件排序，性能就比较差了。</p><h4 id="内存排序"><a href="#内存排序" class="headerlink" title="内存排序"></a>内存排序</h4><h5 id="双路排序"><a href="#双路排序" class="headerlink" title="双路排序"></a>双路排序</h5><p>有一个叫<code>max_length_for_sort_data</code>参数，默认是4096字节，如果select列的数据长度超过它，则MySQl采用<strong>row_id排序</strong>，即把row_id(有主键就是主键)+排序字段放置到<code>sort_buffer</code>中排序。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array</title>
      <link href="/JasmineRain.github.io/2025/08/18/Array/"/>
      <url>/JasmineRain.github.io/2025/08/18/Array/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数组是一种<strong>线性数据结构</strong>，用于存储<strong>相同类型的元素</strong>，在内存中是<strong>连续分配</strong>的</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p><strong>固定长度</strong>:声明时需要确定大小(静态数组)，或者动态数组可以扩展长度(for example:Go’s slice,Java’s ArrayList)</p></li><li><p><strong>随机访问</strong>:通过下标在O(1)的时间内访问任意元素</p></li><li><p><strong>连续存储</strong>:方便计算元素的地址，但插入和删除中间元素可能需要移动大量数据</p></li></ol><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定长数组</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">arr[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态数组 slice</span></span><br><span class="line">s:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定长数组</span></span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数组</span></span><br><span class="line"><span class="type">int</span>[] arr2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>按下标访问，注意下标从0开始</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(arr[<span class="number">0</span>])</span><br><span class="line">fmt.Println(s[<span class="built_in">len</span>(s)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.Println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.Println(arr[arr.length-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++&#123;</span><br><span class="line">    fmt.Println(s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> s&#123;</span><br><span class="line">    fmt.Println(i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:arr)&#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>数组固定长度时中间插入&#x2F;删除效率低，需要移动元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s:=[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">index:=<span class="number">2</span></span><br><span class="line">val:=<span class="number">99</span></span><br><span class="line">s=<span class="built_in">append</span>(s[:index],<span class="built_in">append</span>([]<span class="type">int</span>&#123;val&#125;,s[index:]...)...)</span><br><span class="line">fmt.Println(s)<span class="comment">// [1 2 99 3 4]</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">list.add(<span class="number">2</span>,<span class="number">99</span>);</span><br><span class="line">System.out.Println(list);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStruct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer network</title>
      <link href="/JasmineRain.github.io/2025/08/16/Computer-network/"/>
      <url>/JasmineRain.github.io/2025/08/16/Computer-network/</url>
      
        <content type="html"><![CDATA[<h2 id="basic-network"><a href="#basic-network" class="headerlink" title="basic network"></a>basic network</h2><h3 id="network’s-definition-history-develop"><a href="#network’s-definition-history-develop" class="headerlink" title="network’s definition,history,develop"></a>network’s definition,history,develop</h3><p><strong>computer network</strong>:A collection of autonomous computer systems interconnected in such a way that they can share resources with each other.</p>]]></content>
      
      
      <categories>
          
          <category> Computer network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/JasmineRain.github.io/2025/08/16/Dynamic-Programming/"/>
      <url>/JasmineRain.github.io/2025/08/16/Dynamic-Programming/</url>
      
        <content type="html"><![CDATA[<p>DP is a way that making the question become the more easy little questions to solve.</p><h2 id="basic-dp"><a href="#basic-dp" class="headerlink" title="basic dp"></a>basic dp</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fucking learn damn english</title>
      <link href="/JasmineRain.github.io/2025/08/16/Fucking-learn-damn-english/"/>
      <url>/JasmineRain.github.io/2025/08/16/Fucking-learn-damn-english/</url>
      
        <content type="html"><![CDATA[<p>author<br>accord<br>benefit<br>economic<br>issue<br>impact<br>consumer<br>focus<br>climate<br>concern<br>environment<br>challenge<br>positive<br>process<br>culture<br>community<br>project<br>academic<br>medium<br>design<br>demand<br>mental<br>negative<br>species<br>decade<br>involve<br>remain<br>individual<br>economy<br>expert<br>compare<br>communication<br>account<br>argue<br>access<br>potential<br>claim<br>graduate<br>advantage<br>emotion<br>evidence<br>performance<br>avoid<br>force<br>financial<br>factor<br>disease<br>effective<br>fund<br>cognitive<br>contribute<br>figure<br>protein<br>region<br>attitude<br>management<br>solution<br>fuel<br>insurance<br>behavior<br>credit<br>encourage<br>poverty<br>attract<br>colleague<br>device<br>engage<br>score<br>current<br>professional<br>apply<br>available<br>detail<br>trend</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English Words </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
